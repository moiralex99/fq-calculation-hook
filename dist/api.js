const e={millisecond:1,second:1e3,minute:6e4,hour:36e5,day:864e5,week:6048e5},t=new Set(["day","week","month","quarter","year"]),n=new Set(["month","quarter","year"]);function r(e){return String(e||"").toLowerCase()}function l(e){return new Date(e.getTime())}function a(e){if(null==e||""===e)return null;if(e instanceof Date)return l(e);const t=new Date(e);return Number.isNaN(t.getTime())?null:t}function o(e){if(!e)return null;return`${e.getFullYear()}-${String(e.getMonth()+1).padStart(2,"0")}-${String(e.getDate()).padStart(2,"0")}`}function s(e){return e?e.toISOString():null}function c(e,t){const n=l(e),r=n.getMonth()+t;n.setDate(1),n.setMonth(r);const a=e.getDate(),o=new Date(n.getFullYear(),n.getMonth()+1,0).getDate();return n.setDate(Math.min(a,o)),n}function i(t,n,l){const a=r(n);if(!Number.isFinite(l))return null;if("quarter"===a)return c(t,3*l);if("year"===a)return c(t,12*l);if("month"===a)return c(t,l);const o=e[a];return o?new Date(t.getTime()+l*o):null}function u(e,t){const n=r(t),a=l(e);switch(n){case"day":return a.setHours(0,0,0,0),a;case"week":{const e=(a.getDay()+6)%7;return a.setHours(0,0,0,0),a.setDate(a.getDate()-e),a}case"month":return a.setHours(0,0,0,0),a.setDate(1),a;case"quarter":{a.setHours(0,0,0,0);const e=3*Math.floor(a.getMonth()/3);return a.setMonth(e,1),a}case"year":return a.setHours(0,0,0,0),a.setMonth(0,1),a;default:return a}}function f(e){if(null==e||""===e)return null;const t=Number(e);return Number.isNaN(t)?null:t}function d(e,t,{strict:n=!0}={}){const r=String(t||"").toLowerCase();if(null==e)return null;const l=e=>{if(n)throw new Error(e);return null};switch(r){case"string":case"text":return String(e);case"int":case"integer":case"bigint":{const t=f(e);return null==t?l("Invalid integer cast"):Math.trunc(t)}case"float":case"double":case"decimal":case"numeric":return f(e)??l("Invalid decimal cast");case"bool":case"boolean":{if("boolean"==typeof e)return e;if("number"==typeof e)return 0!==e;const t=String(e).trim().toLowerCase();return!!["true","1","yes","y"].includes(t)||!["false","0","no","n"].includes(t)&&l("Invalid boolean cast")}case"date":{const t=a(e);return t?o(t):l("Invalid date cast")}case"datetime":case"timestamp":{const t=a(e);return t?s(t):l("Invalid datetime cast")}default:return l(`Unsupported cast type: ${t}`)}}class m{constructor(){this.tokenRegex=/(\{\{[a-zA-Z0-9_\.]+\}\}|"(?:[^"\\]|\\.)*"|[0-9]+(?:\.[0-9]+)?|\b(?:IF|CASE_WHEN|COALESCE|ROUND|ABS|CEIL|FLOOR|NULLIF|IS_NULL|IS_BLANK|IN|IN_CI|IN_ANY|BETWEEN|EQ|NE|LT|LTE|GT|GTE|DATE_DIFF|DATEDIFF|DATE_ADD|DATE_TRUNC|EXTRACT|START_OF|END_OF|MAKE_DATE|TODAY|NOW|UPPER|LOWER|LENGTH|LEFT|RIGHT|SUBSTR|SUBSTRING|TRIM|LTRIM|RTRIM|REPLACE|REGEX_MATCH|REGEX_EXTRACT|REGEX_REPLACE|CONCAT|CONCAT_WS|CAST|TRY_CAST|ADD|SUB|MUL|DIV|MOD|NEGATE|POWER|SQRT|SIGN|GREATEST|LEAST|AND|OR|NOT|true|false|null)\b|[+\-*\/%()=<>!,]|<=|>=|<>|!=)/gi}compile(e){if(!e)return()=>null;try{const t=this.dslToJavaScript(e),n=this.createHelpers(),r=Object.entries(n),l=r.map(([e])=>e),a=new Function("data",...l,`\n        return (${t});\n      `);return e=>{const t=r.map(([,e])=>e);return a(e,...t)}}catch(e){throw new Error(`Failed to compile formula: ${e.message}`)}}dslToJavaScript(e){let t=e;t=t.replace(/\{\{([a-zA-Z0-9_]+)\}\}/g,(e,t)=>`(data.${t})`),t=t.replace(/\{\{([a-zA-Z0-9_]+)\.([a-zA-Z0-9_]+)\}\}/g,()=>"null /* cross-collection reference not supported */"),t=t.replace(/\s+AND\s+/gi," && "),t=t.replace(/\s+OR\s+/gi," || "),t=t.replace(/\bNOT\s+/gi,"!"),t=t.replace(/\s*<=\s*/g," __LTE__ "),t=t.replace(/\s*>=\s*/g," __GTE__ "),t=t.replace(/\s*<>\s*/g," __NEQ__ "),t=t.replace(/\s*!=\s*/g," __NEQ__ "),t=t.replace(/\s*<\s*/g," __LT__ "),t=t.replace(/\s*>\s*/g," __GT__ "),t=t.replace(/(?<![=<>!])\s*=\s*(?![=])/g,(e,n)=>{const r=t.substring(0,n),l=(r.match(/"/g)||[]).length,a=(r.match(/'/g)||[]).length;return l%2==1||a%2==1?e:" __EQ__ "}),t=t.replace(/__LTE__/g,"<="),t=t.replace(/__GTE__/g,">="),t=t.replace(/__NEQ__/g,"!=="),t=t.replace(/__LT__/g,"<"),t=t.replace(/__GT__/g,">"),t=t.replace(/__EQ__/g,"==="),t=t.replace(/\band\s*\(/gi,"AND_FUNC("),t=t.replace(/\bor\s*\(/gi,"OR_FUNC("),t=t.replace(/\bnot\s*\(/gi,"NOT_FUNC(");const n=["IF","CASE_WHEN","COALESCE","ROUND","ABS","CEIL","FLOOR","NULLIF","IS_NULL","IS_BLANK","IN","IN_CI","IN_ANY","BETWEEN","EQ","NE","LT","LTE","GT","GTE","DATE_DIFF","DATEDIFF","DATE_ADD","DATE_TRUNC","EXTRACT","START_OF","END_OF","MAKE_DATE","TODAY","NOW","UPPER","LOWER","LENGTH","LEFT","RIGHT","SUBSTR","SUBSTRING","TRIM","LTRIM","RTRIM","REPLACE","REGEX_MATCH","REGEX_EXTRACT","REGEX_REPLACE","CONCAT","CONCAT_WS","CAST","TRY_CAST","ADD","SUB","MUL","DIV","MOD","NEGATE","POWER","SQRT","SIGN","GREATEST","LEAST"];for(const e of n){const n=new RegExp(`\\b${e}\\s*\\(`,"gi");t=t.replace(n,`${e}(`)}return t}createHelpers(){const c={};function m(e){if("boolean"==typeof e)return e;if("number"==typeof e)return 0!==e;if(null==e)return e;const t=String(e).trim().toLowerCase();return!!["true","1","yes","y"].includes(t)||!["false","0","no","n"].includes(t)&&e}function g(e,t){if(null==e&&null==t)return!0;if(null==e||null==t)return!1;const n=function(e,t){const n=f(e),r=f(t);return null!=n&&null!=r?[n,r]:null}(e,t);if(n){const[e,t]=n;return Math.abs(e-t)<1e-7}const r=function(e,t){const n=a(e),r=a(t);return n&&r?[n,r]:null}(e,t);if(r){const[e,t]=r;return e.getTime()===t.getTime()}const l=m(e),o=m(t);return"boolean"==typeof l&&"boolean"==typeof o?l===o:e===t}function h(e){if(null==e)return e;if("number"==typeof e)return e;if("boolean"==typeof e)return e;const t=String(e).trim();if("true"===t||"false"===t)return"true"===t;const n=Number(t);return Number.isNaN(n)?t:n}return c.IF=(e,t,n)=>e?t:n,c.CASE_WHEN=(...e)=>{const t=e.length;for(let n=0;n<t-1;n+=2)if(e[n])return e[n+1];return t%2==1?e[t-1]:null},c.COALESCE=(...e)=>{for(const t of e)if(null!=t&&void 0!==t)return t;return null},c.ROUND=(e,t=2)=>{const n=f(e);if(null==n)return null;const r=10**(t??0);return Math.round(n*r)/r},c.ABS=e=>{const t=f(e);return null==t?null:Math.abs(t)},c.CEIL=e=>{const t=f(e);return null==t?null:Math.ceil(t)},c.FLOOR=e=>{const t=f(e);return null==t?null:Math.floor(t)},c.NULLIF=(e,t)=>e===t?null:e,c.IS_NULL=e=>null==e,c.IS_BLANK=e=>null==e||("string"==typeof e?""===e.trim():!!Array.isArray(e)&&0===e.length),c.IN=(e,...t)=>{const n=Array.isArray(e)?e.map(h):h(e),r=t.flat();for(const e of r){const t=h(e);if(Array.isArray(n)){if(n.some(e=>e===t))return!0}else if(n===t)return!0}return!1},c.IN_CI=(e,...t)=>{const n=e=>null==e?e:String(e).trim().toLowerCase(),r=Array.isArray(e)?e.map(n):[n(e)],l=t.flat().map(n);return r.some(e=>l.includes(e))},c.IN_ANY=(e,...t)=>{const n=Array.isArray(e)?e.map(h):[h(e)];const r=t.flat().map(h);return n.some(e=>r.includes(e))},c.BETWEEN=(e,t,n)=>{if(null==e||null==t||null==n)return!1;const r=a(e),l=a(t),o=a(n);if(r&&l&&o){let e=l.getTime(),t=o.getTime();e>t&&([e,t]=[t,e]);const n=r.getTime();return n>=e&&n<=t}const s=f(e),c=f(t),i=f(n);if(null!=s&&null!=c&&null!=i){let e=c,t=i;return e>t&&([e,t]=[t,e]),s>=e&&s<=t}const u=String(e);let d=String(t),m=String(n);return d>m&&([d,m]=[m,d]),u>=d&&u<=m},c.EQ=(e,t)=>g(e,t),c.NE=(e,t)=>!g(e,t),c.LT=(e,t)=>{const n=f(e),r=f(t);if(null!=n&&null!=r)return n<r;const l=a(e),o=a(t);return l&&o?l.getTime()<o.getTime():e<t},c.LTE=(e,t)=>{const n=f(e),r=f(t);if(null!=n&&null!=r)return n<=r;const l=a(e),o=a(t);return l&&o?l.getTime()<=o.getTime():e<=t},c.GT=(e,t)=>{const n=f(e),r=f(t);if(null!=n&&null!=r)return n>r;const l=a(e),o=a(t);return l&&o?l.getTime()>o.getTime():e>t},c.GTE=(e,t)=>{const n=f(e),r=f(t);if(null!=n&&null!=r)return n>=r;const l=a(e),o=a(t);return l&&o?l.getTime()>=o.getTime():e>=t},c.DATE_DIFF=(t,l,o)=>function(t,l,o){const s=r(t),c=a(l),i=a(o);if(!c||!i)return null;const u=i.getTime()-c.getTime();if(n.has(s)){const e=12*(i.getFullYear()-c.getFullYear())+(i.getMonth()-c.getMonth()),t=i.getDate()-c.getDate();let n=e;if(u>=0&&t<0?n-=1:u<0&&t>0&&(n+=1),"month"===s)return n;if("quarter"===s)return Math.trunc(n/3);if("year"===s)return Math.trunc(n/12)}const f=e[s];return f?Math.trunc(u/f):null}(t,l,o),c.DATEDIFF=(e,t,n)=>c.DATE_DIFF(n,t,e),c.DATE_ADD=(e,n,l)=>{const c=a(l),u=f(n);if(!c||null==u)return null;const d=i(c,e,u);return d?t.has(r(e))?o(d):s(d):null},c.DATE_TRUNC=(e,n)=>{const l=a(n);if(!l)return null;const c=u(l,e);return t.has(r(e))?o(c):s(c)},c.START_OF=(e,t)=>c.DATE_TRUNC(e,t),c.END_OF=(e,n)=>{const c=a(n);if(!c)return null;const f=function(e,t){const n=r(t);if("day"===n){const t=l(e);return t.setHours(23,59,59,999),t}const a=u(e,n),o=i(a,n,1);return o?(o.setMilliseconds(o.getMilliseconds()-1),o):a}(c,e);return t.has(r(e))?o(f):s(f)},c.MAKE_DATE=(e,t,n)=>{const r=f(e),l=f(t),a=f(n);if(null==r||null==l||null==a)return null;const s=new Date(Date.UTC(r,l-1,a));return Number.isNaN(s.getTime())?null:o(s)},c.TODAY=()=>o(new Date),c.NOW=()=>s(new Date),c.EXTRACT=(e,t)=>{const n=a(t);if(!n)return null;switch(r(e)){case"year":return n.getFullYear();case"month":return n.getMonth()+1;case"day":case"day_of_month":return n.getDate();case"hour":return n.getHours();case"minute":return n.getMinutes();case"second":return n.getSeconds();case"quarter":return Math.floor(n.getMonth()/3)+1;case"week":{const e=new Date(Date.UTC(n.getFullYear(),n.getMonth(),n.getDate())),t=e.getUTCDay()||7;e.setUTCDate(e.getUTCDate()+4-t);const r=new Date(Date.UTC(e.getUTCFullYear(),0,1));return Math.ceil(((e-r)/864e5+1)/7)}case"dow":case"day_of_week":return(n.getDay()+6)%7+1;default:return null}},c.UPPER=e=>null!=e?String(e).toUpperCase():"",c.LOWER=e=>null!=e?String(e).toLowerCase():"",c.LENGTH=e=>null!=e?String(e).length:0,c.LEFT=(e,t)=>{const n=null!=e?String(e):"",r=f(t)??0;return n.slice(0,Math.max(0,r))},c.RIGHT=(e,t)=>{const n=null!=e?String(e):"",r=f(t)??0;return 0===r?"":n.slice(-Math.max(0,r))},c.SUBSTR=(e,t,n)=>{const r=null!=e?String(e):"",l=f(t)??0;if(null==n)return r.substring(l);const a=f(n)??0;return r.substring(l,l+a)},c.SUBSTRING=c.SUBSTR,c.TRIM=e=>null!=e?String(e).trim():"",c.LTRIM=e=>null!=e?String(e).trimStart():"",c.RTRIM=e=>null!=e?String(e).trimEnd():"",c.REPLACE=(e,t,n)=>{if(null==e)return"";const r=String(e),l=null!=t?String(t):"",a=null!=n?String(n):"";return""===l?r:r.split(l).join(a)},c.REGEX_MATCH=(e,t)=>{if(null==e||null==t)return!1;return new RegExp(t).test(String(e))},c.REGEX_EXTRACT=(e,t,n=1)=>{if(null==e||null==t)return null;const r=new RegExp(t).exec(String(e));if(!r)return null;const l=null==n?1:Number(n);return r[Number.isNaN(l)?1:l]??null},c.REGEX_REPLACE=(e,t,n="")=>{if(null==e||null==t)return null;const r=new RegExp(t,"g");return String(e).replace(r,n)},c.CONCAT=(...e)=>e.filter(e=>null!=e&&void 0!==e).map(e=>String(e)).join(""),c.CONCAT_WS=(e,...t)=>{const n=null!=e?String(e):"";return t.filter(e=>null!=e&&void 0!==e).map(e=>String(e)).join(n)},c.CAST=(e,t)=>d(e,t,{strict:!0}),c.TRY_CAST=(e,t)=>d(e,t,{strict:!1}),c.ADD=(...e)=>{if(!e.length)return 0;let t=0;for(const n of e){t+=f(n)??0}return t},c.SUB=(...e)=>{if(!e.length)return null;const t=f(e[0]);if(null==t)return null;let n=t;for(let t=1;t<e.length;t++){n-=f(e[t])??0}return n},c.MUL=(...e)=>{if(!e.length)return null;let t=1;for(const n of e){const e=f(n);if(null==e)return null;t*=e}return t},c.DIV=(e,t)=>{const n=f(e),r=f(t);return null==n||null==r||0===r?null:n/r},c.MOD=(e,t)=>{const n=f(e),r=f(t);return null==n||null==r||0===r?null:n%r},c.NEGATE=e=>{const t=f(e);return null==t?null:-t},c.POWER=(e,t)=>{const n=f(e),r=f(t);return null==n||null==r?null:Math.pow(n,r)},c.SQRT=e=>{const t=f(e);return null==t||t<0?null:Math.sqrt(t)},c.SIGN=e=>{const t=f(e);return null==t?null:t>0?1:t<0?-1:0},c.GREATEST=(...e)=>{const t=e.map(f).filter(e=>null!=e);return t.length?Math.max(...t):null},c.LEAST=(...e)=>{const t=e.map(f).filter(e=>null!=e);return t.length?Math.min(...t):null},c.AND_FUNC=(...e)=>e.every(e=>Boolean(e)),c.OR_FUNC=(...e)=>e.some(e=>Boolean(e)),c.NOT_FUNC=e=>!Boolean(e),c}extractFields(e){if(!e)return[];const t=[],n=/\{\{([a-zA-Z0-9_]+(?:\.[a-zA-Z0-9_]+)?)\}\}/g;let r;for(;null!==(r=n.exec(e));)t.push(r[1]);return[...new Set(t)]}extractLocalDependencies(e){return this.extractFields(e).filter(e=>!e.includes("."))}isLocalFormula(e){if(!e)return!0;const t=[/\{\{[a-zA-Z0-9_]+\.[a-zA-Z0-9_]+\}\}/,/\bLOOKUP\s*\(/i,/\bPARENT\s*\(/i,/\bCHILDREN\s*\(/i,/\bRELATED\s*\(/i,/\bSUM\s*\(/i,/\bAVG\s*\(/i,/\bCOUNT\s*\(/i,/\bMIN\s*\(/i,/\bMAX\s*\(/i,/\bCOUNT_DISTINCT\s*\(/i];for(const n of t)if(n.test(e))return!1;return!0}validate(e,t={}){try{const n=this.compile(e);return{valid:!0,result:n(t)}}catch(e){return{valid:!1,error:e.message}}}}class g{constructor(e){this.parser=new m,this.logger=e,this.compiledCache=new Map}evaluate(e,t){try{let n=this.compiledCache.get(e);n||(n=this.parser.compile(e),this.compiledCache.set(e,n));const r=n(t);return this.logger?.debug(`Evaluated: ${e} = ${r}`),r}catch(t){throw this.logger?.error(`Error evaluating formula "${e}":`,t.message),t}}clearCache(){this.compiledCache.clear()}getCacheSize(){return this.compiledCache.size}extractDependencies(e){return this.parser.extractLocalDependencies(e)}isLocal(e){return this.parser.isLocalFormula(e)}isLocalFormula(e){return this.isLocal(e)}}class h{constructor(e,t){this.database=e,this.logger=t,this.parser=new m,this.cachedFormulas=null,this.lastLoadTime=null,this.CACHE_TTL=6e4}async loadFormulas(){try{if(this.cachedFormulas&&this.lastLoadTime&&Date.now()-this.lastLoadTime<this.CACHE_TTL)return this.cachedFormulas;const e=await this.database("quartz_formulas").select("*").where("status","published").orderBy("collection_cible","asc").orderBy("sort","asc").orderBy("champ_cible","asc"),t={};for(const n of e){const e=n.collection_cible;if(!e){this.logger?.warn("[FormulaLoader] Missing collection_cible on row id="+n.id);continue}t[e]||(t[e]={});const r=n.champ_cible,l=n.formula;if(!r||!l){this.logger?.warn(`[FormulaLoader] Missing champ_cible or formula for ${e} (id=${n.id})`);continue}const a=this.parser.extractLocalDependencies(l);t[e][r]={formula:l,dependencies:a,isLocal:this.parser.isLocalFormula(l),metadata:{id:n.id,description:n.description,sort:n.sort,updated_at:n.date_updated}}}return this.cachedFormulas=t,this.lastLoadTime=Date.now(),this.logger?.info(`[FormulaLoader] Loaded ${e.length} formula(s) from ${Object.keys(t).length} collection(s)`),t}catch(e){if(this.logger?.error("[FormulaLoader] Error loading formulas:",e.message),e.message.includes("does not exist"))return this.logger?.warn("[FormulaLoader] Table quartz_formulas not found. Using empty config."),{};throw e}}filterLocalFormulas(e){const t={};let n=0;for(const[r,l]of Object.entries(e)){t[r]={};for(const[e,a]of Object.entries(l))a.isLocal?t[r][e]=a:(this.logger?.info(`[FormulaLoader] Skipping non-local formula: ${r}.${e}`),n++);0===Object.keys(t[r]).length&&delete t[r]}return n>0&&this.logger?.info(`[FormulaLoader] Filtered out ${n} non-local formula(s) (require full engine)`),t}async reloadFormulas(){return this.cachedFormulas=null,this.lastLoadTime=null,await this.loadFormulas()}async loadLocalFormulas(){const e=await this.loadFormulas();return this.filterLocalFormulas(e)}}class p{constructor(e){this.logger=e}buildGraph(e){const t={},n=new Set;for(const[r,l]of Object.entries(e))n.add(r),t[r]={formula:l.formula,dependencies:l.dependencies||[],dependents:[]};for(const[e,n]of Object.entries(t))for(const r of n.dependencies)t[r]&&t[r].dependents.push(e);return t}topologicalSort(e){const t=new Set,n=new Set,r=[],l=[],a=(o,s=[])=>{if(n.has(o)){const e=s.indexOf(o),t=s.slice(e).concat(o);return l.push(t),!1}if(t.has(o))return!0;n.add(o),s.push(o);const c=e[o]?.dependencies||[];for(const t of c)if(e[t]&&!a(t,[...s]))return!1;return n.delete(o),t.add(o),r.push(o),!0};for(const n of Object.keys(e))t.has(n)||a(n);return{order:r,cycles:l}}analyze(e){const t=this.buildGraph(e),{order:n,cycles:r}=this.topologicalSort(t),l=this.calculateLevels(t,n);return r.length>0&&(this.logger?.warn(`[DependencyGraph] Detected ${r.length} circular dependency(ies):`),r.forEach(e=>{this.logger?.warn(`  -> ${e.join(" → ")}`)})),this.logger?.debug(`[DependencyGraph] Calculation order: ${n.join(" → ")}`),{order:n,graph:t,cycles:r,levels:l}}calculateLevels(e,t){const n={};for(const r of t){const t=e[r]?.dependencies||[];let l=-1;for(const e of t)void 0!==n[e]&&(l=Math.max(l,n[e]));n[r]=l+1}return n}getAffectedFields(e,t){const n=new Set,r=[...t],l=new Set;for(;r.length>0;){const t=r.shift();if(!l.has(t)){l.add(t);for(const[l,a]of Object.entries(e))a.dependencies.includes(t)&&(n.has(l)||(n.add(l),r.push(l)))}}return Array.from(n)}optimizeCalculationOrder(e,t,n){const r=this.getAffectedFields(e,n),l=new Set([...n,...r]),a=t.filter(e=>l.has(e));return this.logger?.debug(`[DependencyGraph] Changed: ${n.join(", ")}`),this.logger?.debug(`[DependencyGraph] Recalculate: ${a.join(" → ")}`),a}collectDependencyClosure(e,t){const n=new Set;if(!Array.isArray(t)||0===t.length)return n;const r=t=>{if(t&&!n.has(t))if(e&&e[t]){n.add(t);const l=e[t]?.dependencies||[];for(const t of l)e[t]&&r(t)}else n.add(t)};for(const e of t)r(e);return n}visualize(e){let t="\n=== Dependency Graph ===\n";for(const[n,r]of Object.entries(e))t+=`\n${n}:\n`,r.dependencies.length>0&&(t+=`  depends on: ${r.dependencies.join(", ")}\n`),r.dependents.length>0&&(t+=`  triggers: ${r.dependents.join(", ")}\n`),t+=`  formula: ${r.formula}\n`;return t}}async function T({services:e,database:t,logger:n,getSchema:r,formulaConfigs:l,dependencyGraphs:a,calculateFields:o,dependencyGraph:s}){return async function({collection:c,fields:i=null,filter:u=null,batchSize:f=100,dryRun:d=!1},{schema:m,accountability:g}){if(n.info("[RealTime-Calc] recalculate-collection → start"),n.info(`[RealTime-Calc] Params: collection=${c}, fields=${JSON.stringify(i)}, batchSize=${f}, dryRun=${d}`),!c||"string"!=typeof c)throw new Error('Missing or invalid "collection"');if(n.info(`[RealTime-Calc] formulaConfigs has ${Object.keys(l).length} collection(s)`),!l[c]||0===Object.keys(l[c]).length)return n.warn(`[RealTime-Calc] No local formulas for ${c}`),{success:!0,updated:0,processed:0,total:0,message:`No formulas for collection ${c}`};n.info(`[RealTime-Calc] ${c} has ${Object.keys(l[c]).length} local formula(s)`);const h=Array.isArray(i)?i.map(e=>"string"==typeof e?e:String(e)).filter(Boolean):"string"==typeof i?[i]:[],p=Object.keys(l[c]);let T=null;if(h.length>0){const e=a[c];if(T=s.collectDependencyClosure(e?.graph,h),!T||0===T.size)return{success:!1,error:"no_matching_fields",message:`None of the requested fields (${h.join(", ")}) match local formulas for collection ${c}.`};const t=h.filter(e=>!p.includes(e));t.length>0&&n.warn(`[RealTime-Calc] Some requested fields are not local formulas for ${c}: ${t.join(", ")}`)}const{ItemsService:y}=e,C=new y(c,{database:t,schema:m||("function"==typeof r?await r():void 0),accountability:g});let b=0;const E=Math.max(1,Math.min(500,Number(f)||100));let R=0,S=0,_=0;try{const e=await C.readByQuery({filter:u||{},limit:0,meta:"total_count"});e&&e.meta&&"number"==typeof e.meta.total_count&&(_=e.meta.total_count)}catch{}for(n.info(`[RealTime-Calc] Starting batch processing: total=${_}, limit=${E}`);;){const e=await C.readByQuery({filter:u||{},limit:E,offset:b}),t=Array.isArray(e)?e:e?.data||[];if(!t||0===t.length)break;n.info(`[RealTime-Calc] Processing batch: offset=${b}, size=${t.length}`);for(const e of t){const{updates:t,hasChanges:r}=o(c,e,null,{targetFields:h});if(R++,r&&Object.keys(t).length>0)if(d)S++;else try{await C.updateOne(e.id,t),S++}catch(t){n.error(`[RealTime-Calc] Error updating ${c}.${e.id} during recalc:`,t?.message||t)}}if(b+=t.length,t.length<E)break}const $={success:!0,collection:c,processed:R,updated:S,total:_,dryRun:d,fields:h.length>0?Array.from(T||new Set(h)):p,message:d?`Dry-run: ${S} item(s) would be updated on ${R} processed.`:`Updated ${S} item(s) on ${R} processed.`};return n.info(`[RealTime-Calc] Recalculate → success: ${JSON.stringify($)}`),$}}const y=[{name:"realtime-calc-hook",config:({filter:e,action:t},{services:n,exceptions:r,logger:l,database:a,getSchema:o,env:s})=>{const c=new g(l),i=new h(a,l),u=new p(l),f=new Set;let d={},m={},y=null,C=null,b=null;function E(e){if(null===e||"object"!=typeof e)return JSON.stringify(e);if(Array.isArray(e))return"["+e.map(E).join(",")+"]";return"{"+Object.keys(e).sort().map(t=>`${JSON.stringify(t)}:${E(e[t])}`).join(",")+"}"}function R(e){try{return E(e)}catch(e){return l.warn("[RealTime-Calc] Could not compute config signature:",e?.message||e),""+Date.now()}}async function S({attempts:e=3,settleDelayMs:t=700,reason:n="unknown"}={}){let r=null,a=null;for(let o=1;o<=e;o++){const s=await i.reloadFormulas(),c=i.filterLocalFormulas(s),u=R(c);if(l.debug(`[RealTime-Calc] Reload attempt ${o}/${e} (reason: ${n}) signature: ${u.substring(0,32)}…`),r&&u===r){l.info(`[RealTime-Calc] 🔒 Reload stabilized on attempt ${o} (reason: ${n})`),a=c;break}r=u,a=c,o<e&&await new Promise(e=>setTimeout(e,t))}return await async function(e){d=e||{},m={};for(const[e,t]of Object.entries(d)){const n=u.analyze(t);m[e]=n,n.cycles.length>0&&l.warn(`[RealTime-Calc] Collection ${e} has circular dependencies!`),l.debug(`[RealTime-Calc] ${e}: ${n.order.length} local formula(s) loaded`)}return!0}(a)}function _(e="unknown"){try{y&&clearTimeout(y),y=setTimeout(async()=>{l.info(`[RealTime-Calc] 🔁 Auto-reloading formulas (reason: ${e})...`);if(await S({attempts:3,settleDelayMs:700,reason:e})){const e=Object.values(d).reduce((e,t)=>e+Object.keys(t).length,0),t=Object.fromEntries(Object.entries(d).map(([e,t])=>[e,Object.keys(t).length])),n=Object.fromEntries(Object.entries(d).map(([e,t])=>[e,Object.keys(t)])),r=Object.fromEntries(Object.entries(d).map(([e,t])=>[e,Object.fromEntries(Object.entries(t).map(([e,t])=>[e,t.formula]))]));l.info(`[RealTime-Calc] ✅ Auto-reload complete: ${e} formula(s) active across ${Object.keys(d).length} collection(s)`),l.info(`[RealTime-Calc] 📦 Reload collections: ${JSON.stringify(t)}`),l.debug(`[RealTime-Calc] 📄 Fields per collection: ${JSON.stringify(n)}`),l.info(`[RealTime-Calc] 🧾 Formulas content: ${JSON.stringify(r)}`)}else l.warn("[RealTime-Calc] ⚠️ Auto-reload failed");y=null},5e3)}catch(e){l.error("[RealTime-Calc] Error scheduling formulas reload:",e?.message||e)}}async function $(){try{d=await i.loadLocalFormulas();for(const[e,t]of Object.entries(d)){const n=u.analyze(t);m[e]=n,n.cycles.length>0&&l.warn(`[RealTime-Calc] Collection ${e} has circular dependencies!`),l.debug(`[RealTime-Calc] ${e}: ${n.order.length} local formula(s) loaded`)}return!0}catch(e){return l.error("[RealTime-Calc] Error loading formulas:",e.message),!1}}function O(e,t,n=null,r={}){const{targetFields:a=null}=r,o=d[e];if(!o||0===Object.keys(o).length)return{updates:{},hasChanges:!1};const s=m[e],i=s?.graph,f={};let g=!1;const h=Array.isArray(a)?a.map(e=>"string"==typeof e?e:String(e)).filter(Boolean):"string"==typeof a?[a]:[];let p=null;if(h.length>0){const e=u.collectDependencyClosure(i,h);p=e.size>0?e:new Set(h)}let T=s?.order||Object.keys(o);if(n&&n.length>0&&i&&(T=u.optimizeCalculationOrder(i,s?.order||[],n),0===T.length))return l.debug(`[RealTime-Calc] No fields affected by changes in ${e}`),{updates:{},hasChanges:!1};if(p&&(T=T.filter(e=>p.has(e)),0===T.length))return l.debug(`[RealTime-Calc] No formulas match requested fields in ${e}: ${h.join(", ")}`),{updates:{},hasChanges:!1};for(const n of T){const r=o[n];try{const a={...t,...f},o=c.evaluate(r.formula,a),s=t[n];A(s,o)?l.debug(`[RealTime-Calc] calc ${e}.${n}: unchanged (${s})`):(f[n]=o,g=!0,l.debug(`[RealTime-Calc] calc ${e}.${n}: ${s} → ${o}`))}catch(t){l.error(`[RealTime-Calc] Error calculating ${e}.${n}:`,t.message)}}return{updates:f,hasChanges:g}}function A(e,t){if(e===t)return!0;if(null==e&&null==t)return!0;if(null==e||null==t)return!1;const n=e=>"boolean"==typeof e?e:1===e||"1"===e||"true"===e||0!==e&&"0"!==e&&"false"!==e&&e,r=n(e),l=n(t);if(r===l)return!0;if("number"==typeof r&&"number"==typeof l){if(isNaN(r)&&isNaN(l))return!0;const e=1e-7;return Math.abs(r-l)<e}return("string"==typeof r||"string"==typeof l)&&String(r)===String(l)}t("items.create",async({collection:e,key:t,payload:r},{schema:s,accountability:c})=>{l.info(`[RealTime-Calc] ✨ items.create ACTION for ${e}.${t}`),"quartz_formulas"!==e?(0===Object.keys(d).length&&await $(),d[e]&&0!==Object.keys(d[e]).length?setTimeout(async()=>{try{const{ItemsService:r}=n,i=new r(e,{database:a,schema:s||("function"==typeof o?await o():void 0),accountability:c}),u=await i.readOne(t);l.debug("[RealTime-Calc] Created item data:",u);const{updates:f,hasChanges:d}=O(e,u);d&&Object.keys(f).length>0?(await i.updateOne(t,f),l.info(`[RealTime-Calc] ✅ Updated ${e}.${t} with calculated fields:`,f)):l.debug(`[RealTime-Calc] No calculated fields to update for ${e}.${t}`)}catch(n){l.error(`[RealTime-Calc] ❌ Error in items.create action for ${e}.${t}:`,n.message)}},100):l.debug(`[RealTime-Calc] No formulas for ${e}, skipping`)):_("quartz_formulas.create")}),t("items.update",async({collection:e,keys:t,payload:r},{schema:s,accountability:c})=>{if(l.info(`[RealTime-Calc] ✏️ items.update ACTION for ${e}, keys:`,t),l.debug("[RealTime-Calc] Payload:",r),"quartz_formulas"!==e)if(0===Object.keys(d).length&&await $(),d[e]&&0!==Object.keys(d[e]).length)for(const i of t){const t=`${e}:${i}`;f.has(t)?(l.debug(`[RealTime-Calc] ⏭️ Skipping self-triggered update for ${t}`),f.delete(t)):setTimeout(async()=>{l.info(`[RealTime-Calc] 🔄 Starting setTimeout for ${e}.${i}`);try{const{ItemsService:u}=n;l.info(`[RealTime-Calc] 📦 Creating ItemsService for ${e}`);const m=new u(e,{database:a,schema:s||("function"==typeof o?await o():void 0),accountability:c});l.info(`[RealTime-Calc] 📖 Reading item ${i} from ${e}`);const g=await m.readOne(i);l.info(`[RealTime-Calc] ✅ Got item data for ${i}:`,JSON.stringify(g)),l.debug(`[RealTime-Calc] Updated item data for ${i}:`,g);const h=Object.keys(r);l.info(`[RealTime-Calc] 🧮 Calling calculateFields for ${e} with changedFields: ${h.join(", ")}`),l.info(`[RealTime-Calc] 📊 formulaConfigs for ${e}:`,JSON.stringify(d[e]));const{updates:p,hasChanges:T}=O(e,g,h);if(l.info(`[RealTime-Calc] 📝 calculateFields returned: hasChanges=${T}, updates=${JSON.stringify(p)}`),l.debug(`[RealTime-Calc] changedFields: ${h.join(", ")}`),l.debug("[RealTime-Calc] calculatedUpdates:",p),T&&Object.keys(p).length>0){const n={};Object.keys(p).forEach(e=>{A(p[e],g[e])||(n[e]=p[e],l.info(`[RealTime-Calc] Calculated field ${e} changed: ${g[e]} → ${p[e]}`))}),Object.keys(n).length>0?(f.add(t),await m.updateOne(i,n),l.info(`[RealTime-Calc] ✅ Updated ${e}.${i} with calculated fields:`,n)):l.debug(`[RealTime-Calc] Calculated fields unchanged for ${e}.${i}`)}else l.debug(`[RealTime-Calc] No calculated fields to update for ${e}.${i}`)}catch(t){l.error(`[RealTime-Calc] ❌ Error in items.update action for ${e}.${i}:`),l.error(t)}},100)}else l.debug(`[RealTime-Calc] No formulas for ${e}, skipping`);else _("quartz_formulas.update")}),t("items.delete",async({collection:e,keys:t})=>{l.info(`[RealTime-Calc] 🗑️ items.delete ACTION for ${e}, keys:`,t),"quartz_formulas"!==e||_("quartz_formulas.delete")}),t("realtime-calc.test-formula",async({formula:e,sampleData:t})=>{const n=c.parser.validate(e,t||{});if(n.valid){const t=c.extractDependencies(e),r=c.isLocal(e);return{valid:!0,result:n.result,fields:t,isLocal:r,message:r?`Formula is valid (local). Result: ${n.result}`:`Formula is valid but requires full engine (uses relations/aggregations). Result: ${n.result}`}}return{valid:!1,error:n.error,message:`Formula error: ${n.error}`}}),t("realtime-calc.reload-formulas",async()=>{try{l.info("[RealTime-Calc] 🔄 Reloading formulas from database (stable)...");const e=await S({attempts:3,settleDelayMs:700,reason:"manual"}),t={collections:Object.keys(d).length,totalFormulas:Object.values(d).reduce((e,t)=>e+Object.keys(t).length,0)};l.info(`[RealTime-Calc] ✅ Reloaded ${t.totalFormulas} formula(s) from ${t.collections} collection(s)`);const n=Object.fromEntries(Object.entries(d).map(([e,t])=>[e,Object.fromEntries(Object.entries(t).map(([e,t])=>[e,t.formula]))]));return l.info(`[RealTime-Calc] 🧾 Formulas content: ${JSON.stringify(n)}`),{success:e,message:`Reloaded ${t.totalFormulas} formula(s) from ${t.collections} collection(s)`,stats:t}}catch(e){return l.error("[RealTime-Calc] ❌ Failed to reload formulas:",e),{success:!1,error:e.message,message:`Failed to reload formulas: ${e.message}`}}}),t("realtime-calc.recalculate-collection",async(e,t)=>{try{if(!b)throw new Error("Handler not initialized yet");return await b(e,t||{})}catch(e){return l.error("[RealTime-Calc] ❌ Failed recalculate-collection (action):",e?.message||e),{success:!1,error:e?.message||String(e)}}}),e("realtime-calc.recalculate-collection",async(e,t)=>{l.info("[RealTime-Calc] Filter invoked: realtime-calc.recalculate-collection");try{if(!b)throw new Error("Handler not initialized yet");return await b(e||{},t||{})}catch(e){return l.error("[RealTime-Calc] ❌ Failed recalculate-collection (filter):",e?.message||e),{success:!1,error:e?.message||String(e)}}}),l.info("[RealTime-Calc] Filter attached: realtime-calc.recalculate-collection"),t("realtime-calc.get-config",async()=>{C&&await C;const e={};for(const[t,n]of Object.entries(d))e[t]={formulaCount:Object.keys(n).length,fields:Object.keys(n),hasCircularDeps:m[t]?.cycles.length>0,calculationOrder:m[t]?.order||[]};return{collections:Object.keys(d).length,stats:e}}),C=(async()=>{const e=await $();if(b=await T({services:n,database:a,logger:l,getSchema:o,formulaConfigs:d,dependencyGraphs:m,calculateFields:O,dependencyGraph:u}),e){const e=Object.values(d).reduce((e,t)=>e+Object.keys(t).length,0);l.info("[RealTime-Calc Extension] Loaded successfully"),l.info(`[RealTime-Calc] Monitoring ${Object.keys(d).length} collection(s) with ${e} formula(s)`)}else l.warn("[RealTime-Calc Extension] Started but no formulas loaded (table may not exist yet)")})()}}],C=[{name:"realtime-calc",config:(e,{services:t,database:n,logger:r,emitter:l,getSchema:a})=>{e.post("/reload",async(e,t)=>{try{r.info("[RealTime-Calc Endpoint] Triggering formula reload...");const e=await l.emitAction("realtime-calc.reload-formulas",{});t.json({success:!0,...e,timestamp:(new Date).toISOString()})}catch(e){r.error("[RealTime-Calc Endpoint] Error reloading:",e),t.status(500).json({success:!1,error:e.message,message:`Failed to reload: ${e.message}`})}}),e.get("/status",async(e,t)=>{try{const e=await n("quartz_formulas").where({status:"published"}).select("collection_cible","champ_cible","formula"),r=[...new Set(e.map(e=>e.collection_cible))];t.json({success:!0,totalFormulas:e.length,collections:r.length,collectionNames:r,formulas:e,message:`Found ${e.length} published formula(s) across ${r.length} collection(s)`,timestamp:(new Date).toISOString()})}catch(e){r.error("[RealTime-Calc Endpoint] Error:",e),t.status(500).json({success:!1,error:e.message})}}),e.post("/utils/realtime-calc.reload-formulas",async(e,t)=>{try{const e=await l.emitAction("realtime-calc.reload-formulas",{});t.json(e)}catch(e){r.error("[RealTime-Calc Endpoint] utils.reload-formulas error:",e),t.status(500).json({success:!1,error:e.message})}}),e.post("/utils/realtime-calc.get-config",async(e,t)=>{try{const e=await l.emitAction("realtime-calc.get-config",{});t.json(e)}catch(e){r.error("[RealTime-Calc Endpoint] utils.get-config error:",e),t.status(500).json({success:!1,error:e.message})}}),e.post("/utils/realtime-calc.recalculate-collection",async(e,l)=>{try{r.info("[RealTime-Calc Endpoint] Requête recalculate-collection reçue");const{collection:o,fields:s=null,filter:c=null,batchSize:i=100,dryRun:u=!1}=e.body||{};r.info(`[RealTime-Calc Endpoint] Paramètres: collection=${o}, fields=${JSON.stringify(s)}, batchSize=${i}, dryRun=${u}`);const f=new h(n,r),d=new p(r),m=new g(r);r.info("[RealTime-Calc Endpoint] Loading formulas...");const y=await f.loadLocalFormulas(),C={};for(const[A,N]of Object.entries(y)){const w=d.analyze(N);C[A]=w}const b=Object.values(y).reduce((e,t)=>e+Object.keys(t).length,0);function E(e,t,n=null,l={}){const a=y[e];if(!a||0===Object.keys(a).length)return{updates:{},hasChanges:!1};const o=C[e];let s=o?.order||Object.keys(a);const c={};let i=!1;const{targetFields:u=null}=l,f=Array.isArray(u)?u.map(e=>"string"==typeof e?e:String(e)).filter(Boolean):"string"==typeof u?[u]:[];let g=null;f.length>0&&(g=d.collectDependencyClosure(o?.graph,f)),n&&n.length>0&&o?.graph&&(s=d.optimizeCalculationOrder(o.graph,o.order||[],n)),g&&(s=s.filter(e=>g.has(e)));for(const n of s){const l=a[n];try{const e={...t,...c},r=m.evaluate(l.formula,e);r!==t[n]&&(c[n]=r,i=!0)}catch(t){r.error(`[RealTime-Calc Endpoint] Error calculating ${e}.${n}:`,t.message)}}return{updates:c,hasChanges:i}}r.info(`[RealTime-Calc Endpoint] Loaded ${b} formula(s) for ${Object.keys(y).length} collection(s)`),r.info("[RealTime-Calc Endpoint] Creating recalculation handler...");const R=await T({services:t,database:n,logger:r,getSchema:a,formulaConfigs:y,dependencyGraphs:C,calculateFields:E,dependencyGraph:d}),S="function"==typeof a?await a():void 0,_={collection:o,fields:s,filter:c,batchSize:i,dryRun:u},$={schema:S,accountability:e.accountability};r.info("[RealTime-Calc Endpoint] Executing handler...");const O=await R(_,$);r.info(`[RealTime-Calc Endpoint] ✅ Result: ${JSON.stringify(O)}`),l.json(O)}catch(D){r.error("[RealTime-Calc Endpoint] ❌ utils.recalculate-collection error:",D),l.status(500).json({success:!1,error:D.message})}})}}],b=[];export{C as endpoints,y as hooks,b as operations};
