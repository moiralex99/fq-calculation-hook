const e={millisecond:1,second:1e3,minute:6e4,hour:36e5,day:864e5,week:6048e5},t=new Set(["day","week","month","quarter","year"]),n=new Set(["month","quarter","year"]);function r(e){return String(e||"").toLowerCase()}function l(e){return new Date(e.getTime())}function a(e){if(null==e||""===e)return null;if(e instanceof Date)return l(e);const t=new Date(e);return Number.isNaN(t.getTime())?null:t}function s(e){if(!e)return null;return`${e.getFullYear()}-${String(e.getMonth()+1).padStart(2,"0")}-${String(e.getDate()).padStart(2,"0")}`}function o(e){return e?e.toISOString():null}function i(e,t){const n=l(e),r=n.getMonth()+t;n.setDate(1),n.setMonth(r);const a=e.getDate(),s=new Date(n.getFullYear(),n.getMonth()+1,0).getDate();return n.setDate(Math.min(a,s)),n}function c(t,n,l){const a=r(n);if(!Number.isFinite(l))return null;if("quarter"===a)return i(t,3*l);if("year"===a)return i(t,12*l);if("month"===a)return i(t,l);const s=e[a];return s?new Date(t.getTime()+l*s):null}function u(e,t){const n=r(t),a=l(e);switch(n){case"day":return a.setHours(0,0,0,0),a;case"week":{const e=(a.getDay()+6)%7;return a.setHours(0,0,0,0),a.setDate(a.getDate()-e),a}case"month":return a.setHours(0,0,0,0),a.setDate(1),a;case"quarter":{a.setHours(0,0,0,0);const e=3*Math.floor(a.getMonth()/3);return a.setMonth(e,1),a}case"year":return a.setHours(0,0,0,0),a.setMonth(0,1),a;default:return a}}function f(e){if(null==e||""===e)return null;const t=Number(e);return Number.isNaN(t)?null:t}function d(e,t,{strict:n=!0}={}){const r=String(t||"").toLowerCase();if(null==e)return null;const l=e=>{if(n)throw new Error(e);return null};switch(r){case"string":case"text":return String(e);case"int":case"integer":case"bigint":{const t=f(e);return null==t?l("Invalid integer cast"):Math.trunc(t)}case"float":case"double":case"decimal":case"numeric":return f(e)??l("Invalid decimal cast");case"bool":case"boolean":{if("boolean"==typeof e)return e;if("number"==typeof e)return 0!==e;const t=String(e).trim().toLowerCase();return!!["true","1","yes","y"].includes(t)||!["false","0","no","n"].includes(t)&&l("Invalid boolean cast")}case"date":{const t=a(e);return t?s(t):l("Invalid date cast")}case"datetime":case"timestamp":{const t=a(e);return t?o(t):l("Invalid datetime cast")}default:return l(`Unsupported cast type: ${t}`)}}class m{constructor(){this.tokenRegex=/(\{\{[a-zA-Z0-9_\.]+\}\}|"(?:[^"\\]|\\.)*"|[0-9]+(?:\.[0-9]+)?|\b(?:IF|CASE_WHEN|COALESCE|ROUND|ABS|CEIL|FLOOR|NULLIF|IS_NULL|IN|IN_CI|IN_ANY|BETWEEN|EQ|NE|LT|LTE|GT|GTE|DATE_DIFF|DATEDIFF|DATE_ADD|DATE_TRUNC|EXTRACT|START_OF|END_OF|MAKE_DATE|TODAY|NOW|UPPER|LOWER|LENGTH|LEFT|RIGHT|SUBSTR|SUBSTRING|TRIM|LTRIM|RTRIM|REPLACE|REGEX_MATCH|REGEX_EXTRACT|REGEX_REPLACE|CONCAT|CONCAT_WS|CAST|TRY_CAST|ADD|SUB|MUL|DIV|MOD|NEGATE|POWER|SQRT|SIGN|GREATEST|LEAST|AND|OR|NOT|true|false|null)\b|[+\-*\/%()=<>!,]|<=|>=|<>|!=)/gi}compile(e){if(!e)return()=>null;try{const t=this.dslToJavaScript(e),n=this.createHelpers(),r=Object.entries(n),l=r.map(([e])=>e),a=new Function("data",...l,`\n        return (${t});\n      `);return e=>{const t=r.map(([,e])=>e);return a(e,...t)}}catch(e){throw new Error(`Failed to compile formula: ${e.message}`)}}dslToJavaScript(e){let t=e;t=t.replace(/\{\{([a-zA-Z0-9_]+)\}\}/g,(e,t)=>`(data.${t})`),t=t.replace(/\{\{([a-zA-Z0-9_]+)\.([a-zA-Z0-9_]+)\}\}/g,()=>"null /* cross-collection reference not supported */"),t=t.replace(/\s+AND\s+/gi," && "),t=t.replace(/\s+OR\s+/gi," || "),t=t.replace(/\bNOT\s+/gi,"!"),t=t.replace(/\s*<=\s*/g," __LTE__ "),t=t.replace(/\s*>=\s*/g," __GTE__ "),t=t.replace(/\s*<>\s*/g," __NEQ__ "),t=t.replace(/\s*!=\s*/g," __NEQ__ "),t=t.replace(/\s*<\s*/g," __LT__ "),t=t.replace(/\s*>\s*/g," __GT__ "),t=t.replace(/(?<![=<>!])\s*=\s*(?![=])/g,(e,n)=>{const r=t.substring(0,n),l=(r.match(/"/g)||[]).length,a=(r.match(/'/g)||[]).length;return l%2==1||a%2==1?e:" __EQ__ "}),t=t.replace(/__LTE__/g,"<="),t=t.replace(/__GTE__/g,">="),t=t.replace(/__NEQ__/g,"!=="),t=t.replace(/__LT__/g,"<"),t=t.replace(/__GT__/g,">"),t=t.replace(/__EQ__/g,"==="),t=t.replace(/\band\s*\(/gi,"AND_FUNC("),t=t.replace(/\bor\s*\(/gi,"OR_FUNC("),t=t.replace(/\bnot\s*\(/gi,"NOT_FUNC(");const n=["IF","CASE_WHEN","COALESCE","ROUND","ABS","CEIL","FLOOR","NULLIF","IS_NULL","IN","IN_CI","IN_ANY","BETWEEN","EQ","NE","LT","LTE","GT","GTE","DATE_DIFF","DATEDIFF","DATE_ADD","DATE_TRUNC","EXTRACT","START_OF","END_OF","MAKE_DATE","TODAY","NOW","UPPER","LOWER","LENGTH","LEFT","RIGHT","SUBSTR","SUBSTRING","TRIM","LTRIM","RTRIM","REPLACE","REGEX_MATCH","REGEX_EXTRACT","REGEX_REPLACE","CONCAT","CONCAT_WS","CAST","TRY_CAST","ADD","SUB","MUL","DIV","MOD","NEGATE","POWER","SQRT","SIGN","GREATEST","LEAST"];for(const e of n){const n=new RegExp(`\\b${e}\\s*\\(`,"gi");t=t.replace(n,`${e}(`)}return t}createHelpers(){const i={};function m(e){if("boolean"==typeof e)return e;if("number"==typeof e)return 0!==e;if(null==e)return e;const t=String(e).trim().toLowerCase();return!!["true","1","yes","y"].includes(t)||!["false","0","no","n"].includes(t)&&e}function g(e,t){if(null==e&&null==t)return!0;if(null==e||null==t)return!1;const n=function(e,t){const n=f(e),r=f(t);return null!=n&&null!=r?[n,r]:null}(e,t);if(n){const[e,t]=n;return Math.abs(e-t)<1e-7}const r=function(e,t){const n=a(e),r=a(t);return n&&r?[n,r]:null}(e,t);if(r){const[e,t]=r;return e.getTime()===t.getTime()}const l=m(e),s=m(t);return"boolean"==typeof l&&"boolean"==typeof s?l===s:e===t}function h(e){if(null==e)return e;if("number"==typeof e)return e;if("boolean"==typeof e)return e;const t=String(e).trim();if("true"===t||"false"===t)return"true"===t;const n=Number(t);return Number.isNaN(n)?t:n}return i.IF=(e,t,n)=>e?t:n,i.CASE_WHEN=(...e)=>{const t=e.length;for(let n=0;n<t-1;n+=2)if(e[n])return e[n+1];return t%2==1?e[t-1]:null},i.COALESCE=(...e)=>{for(const t of e)if(null!=t&&void 0!==t)return t;return null},i.ROUND=(e,t=2)=>{const n=f(e);if(null==n)return null;const r=10**(t??0);return Math.round(n*r)/r},i.ABS=e=>{const t=f(e);return null==t?null:Math.abs(t)},i.CEIL=e=>{const t=f(e);return null==t?null:Math.ceil(t)},i.FLOOR=e=>{const t=f(e);return null==t?null:Math.floor(t)},i.NULLIF=(e,t)=>e===t?null:e,i.IS_NULL=e=>null==e,i.IN=(e,...t)=>{const n=Array.isArray(e)?e.map(h):h(e),r=t.flat();for(const e of r){const t=h(e);if(Array.isArray(n)){if(n.some(e=>e===t))return!0}else if(n===t)return!0}return!1},i.IN_CI=(e,...t)=>{const n=e=>null==e?e:String(e).trim().toLowerCase(),r=Array.isArray(e)?e.map(n):[n(e)],l=t.flat().map(n);return r.some(e=>l.includes(e))},i.IN_ANY=(e,...t)=>{const n=Array.isArray(e)?e.map(h):[h(e)];const r=t.flat().map(h);return n.some(e=>r.includes(e))},i.BETWEEN=(e,t,n)=>{if(null==e||null==t||null==n)return!1;const r=a(e),l=a(t),s=a(n);if(r&&l&&s){let e=l.getTime(),t=s.getTime();e>t&&([e,t]=[t,e]);const n=r.getTime();return n>=e&&n<=t}const o=f(e),i=f(t),c=f(n);if(null!=o&&null!=i&&null!=c){let e=i,t=c;return e>t&&([e,t]=[t,e]),o>=e&&o<=t}const u=String(e);let d=String(t),m=String(n);return d>m&&([d,m]=[m,d]),u>=d&&u<=m},i.EQ=(e,t)=>g(e,t),i.NE=(e,t)=>!g(e,t),i.LT=(e,t)=>{const n=f(e),r=f(t);if(null!=n&&null!=r)return n<r;const l=a(e),s=a(t);return l&&s?l.getTime()<s.getTime():e<t},i.LTE=(e,t)=>{const n=f(e),r=f(t);if(null!=n&&null!=r)return n<=r;const l=a(e),s=a(t);return l&&s?l.getTime()<=s.getTime():e<=t},i.GT=(e,t)=>{const n=f(e),r=f(t);if(null!=n&&null!=r)return n>r;const l=a(e),s=a(t);return l&&s?l.getTime()>s.getTime():e>t},i.GTE=(e,t)=>{const n=f(e),r=f(t);if(null!=n&&null!=r)return n>=r;const l=a(e),s=a(t);return l&&s?l.getTime()>=s.getTime():e>=t},i.DATE_DIFF=(t,l,s)=>function(t,l,s){const o=r(t),i=a(l),c=a(s);if(!i||!c)return null;const u=c.getTime()-i.getTime();if(n.has(o)){const e=12*(c.getFullYear()-i.getFullYear())+(c.getMonth()-i.getMonth()),t=c.getDate()-i.getDate();let n=e;if(u>=0&&t<0?n-=1:u<0&&t>0&&(n+=1),"month"===o)return n;if("quarter"===o)return Math.trunc(n/3);if("year"===o)return Math.trunc(n/12)}const f=e[o];return f?Math.trunc(u/f):null}(t,l,s),i.DATEDIFF=(e,t,n)=>i.DATE_DIFF(n,t,e),i.DATE_ADD=(e,n,l)=>{const i=a(l),u=f(n);if(!i||null==u)return null;const d=c(i,e,u);return d?t.has(r(e))?s(d):o(d):null},i.DATE_TRUNC=(e,n)=>{const l=a(n);if(!l)return null;const i=u(l,e);return t.has(r(e))?s(i):o(i)},i.START_OF=(e,t)=>i.DATE_TRUNC(e,t),i.END_OF=(e,n)=>{const i=a(n);if(!i)return null;const f=function(e,t){const n=r(t);if("day"===n){const t=l(e);return t.setHours(23,59,59,999),t}const a=u(e,n),s=c(a,n,1);return s?(s.setMilliseconds(s.getMilliseconds()-1),s):a}(i,e);return t.has(r(e))?s(f):o(f)},i.MAKE_DATE=(e,t,n)=>{const r=f(e),l=f(t),a=f(n);if(null==r||null==l||null==a)return null;const o=new Date(Date.UTC(r,l-1,a));return Number.isNaN(o.getTime())?null:s(o)},i.TODAY=()=>s(new Date),i.NOW=()=>o(new Date),i.EXTRACT=(e,t)=>{const n=a(t);if(!n)return null;switch(r(e)){case"year":return n.getFullYear();case"month":return n.getMonth()+1;case"day":case"day_of_month":return n.getDate();case"hour":return n.getHours();case"minute":return n.getMinutes();case"second":return n.getSeconds();case"quarter":return Math.floor(n.getMonth()/3)+1;case"week":{const e=new Date(Date.UTC(n.getFullYear(),n.getMonth(),n.getDate())),t=e.getUTCDay()||7;e.setUTCDate(e.getUTCDate()+4-t);const r=new Date(Date.UTC(e.getUTCFullYear(),0,1));return Math.ceil(((e-r)/864e5+1)/7)}case"dow":case"day_of_week":return(n.getDay()+6)%7+1;default:return null}},i.UPPER=e=>null!=e?String(e).toUpperCase():"",i.LOWER=e=>null!=e?String(e).toLowerCase():"",i.LENGTH=e=>null!=e?String(e).length:0,i.LEFT=(e,t)=>{const n=null!=e?String(e):"",r=f(t)??0;return n.slice(0,Math.max(0,r))},i.RIGHT=(e,t)=>{const n=null!=e?String(e):"",r=f(t)??0;return 0===r?"":n.slice(-Math.max(0,r))},i.SUBSTR=(e,t,n)=>{const r=null!=e?String(e):"",l=f(t)??0;if(null==n)return r.substring(l);const a=f(n)??0;return r.substring(l,l+a)},i.SUBSTRING=i.SUBSTR,i.TRIM=e=>null!=e?String(e).trim():"",i.LTRIM=e=>null!=e?String(e).trimStart():"",i.RTRIM=e=>null!=e?String(e).trimEnd():"",i.REPLACE=(e,t,n)=>{if(null==e)return"";const r=String(e),l=null!=t?String(t):"",a=null!=n?String(n):"";return""===l?r:r.split(l).join(a)},i.REGEX_MATCH=(e,t)=>{if(null==e||null==t)return!1;return new RegExp(t).test(String(e))},i.REGEX_EXTRACT=(e,t,n=1)=>{if(null==e||null==t)return null;const r=new RegExp(t).exec(String(e));if(!r)return null;const l=null==n?1:Number(n);return r[Number.isNaN(l)?1:l]??null},i.REGEX_REPLACE=(e,t,n="")=>{if(null==e||null==t)return null;const r=new RegExp(t,"g");return String(e).replace(r,n)},i.CONCAT=(...e)=>e.filter(e=>null!=e&&void 0!==e).map(e=>String(e)).join(""),i.CONCAT_WS=(e,...t)=>{const n=null!=e?String(e):"";return t.filter(e=>null!=e&&void 0!==e).map(e=>String(e)).join(n)},i.CAST=(e,t)=>d(e,t,{strict:!0}),i.TRY_CAST=(e,t)=>d(e,t,{strict:!1}),i.ADD=(...e)=>{if(!e.length)return 0;let t=0;for(const n of e){t+=f(n)??0}return t},i.SUB=(...e)=>{if(!e.length)return null;const t=f(e[0]);if(null==t)return null;let n=t;for(let t=1;t<e.length;t++){n-=f(e[t])??0}return n},i.MUL=(...e)=>{if(!e.length)return null;let t=1;for(const n of e){const e=f(n);if(null==e)return null;t*=e}return t},i.DIV=(e,t)=>{const n=f(e),r=f(t);return null==n||null==r||0===r?null:n/r},i.MOD=(e,t)=>{const n=f(e),r=f(t);return null==n||null==r||0===r?null:n%r},i.NEGATE=e=>{const t=f(e);return null==t?null:-t},i.POWER=(e,t)=>{const n=f(e),r=f(t);return null==n||null==r?null:Math.pow(n,r)},i.SQRT=e=>{const t=f(e);return null==t||t<0?null:Math.sqrt(t)},i.SIGN=e=>{const t=f(e);return null==t?null:t>0?1:t<0?-1:0},i.GREATEST=(...e)=>{const t=e.map(f).filter(e=>null!=e);return t.length?Math.max(...t):null},i.LEAST=(...e)=>{const t=e.map(f).filter(e=>null!=e);return t.length?Math.min(...t):null},i.AND_FUNC=(...e)=>e.every(e=>Boolean(e)),i.OR_FUNC=(...e)=>e.some(e=>Boolean(e)),i.NOT_FUNC=e=>!Boolean(e),i}extractFields(e){if(!e)return[];const t=[],n=/\{\{([a-zA-Z0-9_]+(?:\.[a-zA-Z0-9_]+)?)\}\}/g;let r;for(;null!==(r=n.exec(e));)t.push(r[1]);return[...new Set(t)]}extractLocalDependencies(e){return this.extractFields(e).filter(e=>!e.includes("."))}isLocalFormula(e){if(!e)return!0;const t=[/\{\{[a-zA-Z0-9_]+\.[a-zA-Z0-9_]+\}\}/,/\bLOOKUP\s*\(/i,/\bPARENT\s*\(/i,/\bCHILDREN\s*\(/i,/\bRELATED\s*\(/i,/\bSUM\s*\(/i,/\bAVG\s*\(/i,/\bCOUNT\s*\(/i,/\bMIN\s*\(/i,/\bMAX\s*\(/i,/\bCOUNT_DISTINCT\s*\(/i];for(const n of t)if(n.test(e))return!1;return!0}validate(e,t={}){try{const n=this.compile(e);return{valid:!0,result:n(t)}}catch(e){return{valid:!1,error:e.message}}}}class g{constructor(e){this.parser=new m,this.logger=e,this.compiledCache=new Map}evaluate(e,t){try{let n=this.compiledCache.get(e);n||(n=this.parser.compile(e),this.compiledCache.set(e,n));const r=n(t);return this.logger?.debug(`Evaluated: ${e} = ${r}`),r}catch(t){throw this.logger?.error(`Error evaluating formula "${e}":`,t.message),t}}clearCache(){this.compiledCache.clear()}getCacheSize(){return this.compiledCache.size}extractDependencies(e){return this.parser.extractLocalDependencies(e)}isLocal(e){return this.parser.isLocalFormula(e)}isLocalFormula(e){return this.isLocal(e)}}class h{constructor(e,t){this.database=e,this.logger=t,this.parser=new m,this.cachedFormulas=null,this.lastLoadTime=null,this.CACHE_TTL=6e4}async loadFormulas(){try{if(this.cachedFormulas&&this.lastLoadTime&&Date.now()-this.lastLoadTime<this.CACHE_TTL)return this.cachedFormulas;const e=await this.database("quartz_formulas").select("*").where("status","published").orderBy("collection_cible","asc").orderBy("sort","asc").orderBy("champ_cible","asc"),t={};for(const n of e){const e=n.collection_cible;if(!e){this.logger?.warn("[FormulaLoader] Missing collection_cible on row id="+n.id);continue}t[e]||(t[e]={});const r=n.champ_cible,l=n.formula;if(!r||!l){this.logger?.warn(`[FormulaLoader] Missing champ_cible or formula for ${e} (id=${n.id})`);continue}const a=this.parser.extractLocalDependencies(l);t[e][r]={formula:l,dependencies:a,isLocal:this.parser.isLocalFormula(l),metadata:{id:n.id,description:n.description,sort:n.sort,updated_at:n.date_updated}}}return this.cachedFormulas=t,this.lastLoadTime=Date.now(),this.logger?.info(`[FormulaLoader] Loaded ${e.length} formula(s) from ${Object.keys(t).length} collection(s)`),t}catch(e){if(this.logger?.error("[FormulaLoader] Error loading formulas:",e.message),e.message.includes("does not exist"))return this.logger?.warn("[FormulaLoader] Table quartz_formulas not found. Using empty config."),{};throw e}}filterLocalFormulas(e){const t={};let n=0;for(const[r,l]of Object.entries(e)){t[r]={};for(const[e,a]of Object.entries(l))a.isLocal?t[r][e]=a:(this.logger?.info(`[FormulaLoader] Skipping non-local formula: ${r}.${e}`),n++);0===Object.keys(t[r]).length&&delete t[r]}return n>0&&this.logger?.info(`[FormulaLoader] Filtered out ${n} non-local formula(s) (require full engine)`),t}async reloadFormulas(){return this.cachedFormulas=null,this.lastLoadTime=null,await this.loadFormulas()}async loadLocalFormulas(){const e=await this.loadFormulas();return this.filterLocalFormulas(e)}}class T{constructor(e){this.logger=e}buildGraph(e){const t={},n=new Set;for(const[r,l]of Object.entries(e))n.add(r),t[r]={formula:l.formula,dependencies:l.dependencies||[],dependents:[]};for(const[e,n]of Object.entries(t))for(const r of n.dependencies)t[r]&&t[r].dependents.push(e);return t}topologicalSort(e){const t=new Set,n=new Set,r=[],l=[],a=(s,o=[])=>{if(n.has(s)){const e=o.indexOf(s),t=o.slice(e).concat(s);return l.push(t),!1}if(t.has(s))return!0;n.add(s),o.push(s);const i=e[s]?.dependencies||[];for(const t of i)if(e[t]&&!a(t,[...o]))return!1;return n.delete(s),t.add(s),r.push(s),!0};for(const n of Object.keys(e))t.has(n)||a(n);return{order:r,cycles:l}}analyze(e){const t=this.buildGraph(e),{order:n,cycles:r}=this.topologicalSort(t),l=this.calculateLevels(t,n);return r.length>0&&(this.logger?.warn(`[DependencyGraph] Detected ${r.length} circular dependency(ies):`),r.forEach(e=>{this.logger?.warn(`  -> ${e.join(" → ")}`)})),this.logger?.debug(`[DependencyGraph] Calculation order: ${n.join(" → ")}`),{order:n,graph:t,cycles:r,levels:l}}calculateLevels(e,t){const n={};for(const r of t){const t=e[r]?.dependencies||[];let l=-1;for(const e of t)void 0!==n[e]&&(l=Math.max(l,n[e]));n[r]=l+1}return n}getAffectedFields(e,t){const n=new Set,r=[...t],l=new Set;for(;r.length>0;){const t=r.shift();if(!l.has(t)){l.add(t);for(const[l,a]of Object.entries(e))a.dependencies.includes(t)&&(n.has(l)||(n.add(l),r.push(l)))}}return Array.from(n)}optimizeCalculationOrder(e,t,n){const r=this.getAffectedFields(e,n),l=new Set([...n,...r]),a=t.filter(e=>l.has(e));return this.logger?.debug(`[DependencyGraph] Changed: ${n.join(", ")}`),this.logger?.debug(`[DependencyGraph] Recalculate: ${a.join(" → ")}`),a}visualize(e){let t="\n=== Dependency Graph ===\n";for(const[n,r]of Object.entries(e))t+=`\n${n}:\n`,r.dependencies.length>0&&(t+=`  depends on: ${r.dependencies.join(", ")}\n`),r.dependents.length>0&&(t+=`  triggers: ${r.dependents.join(", ")}\n`),t+=`  formula: ${r.formula}\n`;return t}}var p=({filter:e,action:t},{services:n,exceptions:r,logger:l,database:a,getSchema:s,env:o})=>{const i=new g(l),c=new h(a,l),u=new T(l),f=new Set;let d={},m={},p=null;function y(e){if(null===e||"object"!=typeof e)return JSON.stringify(e);if(Array.isArray(e))return"["+e.map(y).join(",")+"]";return"{"+Object.keys(e).sort().map(t=>`${JSON.stringify(t)}:${y(e[t])}`).join(",")+"}"}function E(e){try{return y(e)}catch(e){return l.warn("[RealTime-Calc] Could not compute config signature:",e?.message||e),""+Date.now()}}async function C({attempts:e=3,settleDelayMs:t=700,reason:n="unknown"}={}){let r=null,a=null;for(let s=1;s<=e;s++){const o=await c.reloadFormulas(),i=c.filterLocalFormulas(o),u=E(i);if(l.debug(`[RealTime-Calc] Reload attempt ${s}/${e} (reason: ${n}) signature: ${u.substring(0,32)}…`),r&&u===r){l.info(`[RealTime-Calc] 🔒 Reload stabilized on attempt ${s} (reason: ${n})`),a=i;break}r=u,a=i,s<e&&await new Promise(e=>setTimeout(e,t))}return await async function(e){d=e||{},m={};for(const[e,t]of Object.entries(d)){const n=u.analyze(t);m[e]=n,n.cycles.length>0&&l.warn(`[RealTime-Calc] Collection ${e} has circular dependencies!`),l.debug(`[RealTime-Calc] ${e}: ${n.order.length} local formula(s) loaded`)}return!0}(a)}function b(e="unknown"){try{p&&clearTimeout(p),p=setTimeout(async()=>{l.info(`[RealTime-Calc] 🔁 Auto-reloading formulas (reason: ${e})...`);if(await C({attempts:3,settleDelayMs:700,reason:e})){const e=Object.values(d).reduce((e,t)=>e+Object.keys(t).length,0),t=Object.fromEntries(Object.entries(d).map(([e,t])=>[e,Object.keys(t).length])),n=Object.fromEntries(Object.entries(d).map(([e,t])=>[e,Object.keys(t)])),r=Object.fromEntries(Object.entries(d).map(([e,t])=>[e,Object.fromEntries(Object.entries(t).map(([e,t])=>[e,t.formula]))]));l.info(`[RealTime-Calc] ✅ Auto-reload complete: ${e} formula(s) active across ${Object.keys(d).length} collection(s)`),l.info(`[RealTime-Calc] 📦 Reload collections: ${JSON.stringify(t)}`),l.debug(`[RealTime-Calc] 📄 Fields per collection: ${JSON.stringify(n)}`),l.info(`[RealTime-Calc] 🧾 Formulas content: ${JSON.stringify(r)}`)}else l.warn("[RealTime-Calc] ⚠️ Auto-reload failed");p=null},5e3)}catch(e){l.error("[RealTime-Calc] Error scheduling formulas reload:",e?.message||e)}}async function R(){try{d=await c.loadLocalFormulas();for(const[e,t]of Object.entries(d)){const n=u.analyze(t);m[e]=n,n.cycles.length>0&&l.warn(`[RealTime-Calc] Collection ${e} has circular dependencies!`),l.debug(`[RealTime-Calc] ${e}: ${n.order.length} local formula(s) loaded`)}return!0}catch(e){return l.error("[RealTime-Calc] Error loading formulas:",e.message),!1}}function _(e,t,n=null){const r=d[e];if(!r||0===Object.keys(r).length)return{updates:{},hasChanges:!1};const a=m[e],s={};let o=!1,c=a?.order||Object.keys(r);if(n&&n.length>0&&a&&(c=u.optimizeCalculationOrder(a.graph,a.order,n),0===c.length))return l.debug(`[RealTime-Calc] No fields affected by changes in ${e}`),{updates:{},hasChanges:!1};for(const n of c){const a=r[n];try{const r={...t,...s},c=i.evaluate(a.formula,r),u=t[n];S(u,c)?l.debug(`[RealTime-Calc] calc ${e}.${n}: unchanged (${u})`):(s[n]=c,o=!0,l.debug(`[RealTime-Calc] calc ${e}.${n}: ${u} → ${c}`))}catch(t){l.error(`[RealTime-Calc] Error calculating ${e}.${n}:`,t.message)}}return{updates:s,hasChanges:o}}function S(e,t){if(e===t)return!0;if(null==e&&null==t)return!0;if(null==e||null==t)return!1;const n=e=>"boolean"==typeof e?e:1===e||"1"===e||"true"===e||0!==e&&"0"!==e&&"false"!==e&&e,r=n(e),l=n(t);if(r===l)return!0;if("number"==typeof r&&"number"==typeof l){if(isNaN(r)&&isNaN(l))return!0;const e=1e-7;return Math.abs(r-l)<e}return("string"==typeof r||"string"==typeof l)&&String(r)===String(l)}t("items.create",async({collection:e,key:t,payload:r},{schema:o,accountability:i})=>{l.info(`[RealTime-Calc] ✨ items.create ACTION for ${e}.${t}`),"quartz_formulas"!==e?(0===Object.keys(d).length&&await R(),d[e]&&0!==Object.keys(d[e]).length?setTimeout(async()=>{try{const{ItemsService:r}=n,c=new r(e,{database:a,schema:o||("function"==typeof s?await s():void 0),accountability:i}),u=await c.readOne(t);l.debug("[RealTime-Calc] Created item data:",u);const{updates:f,hasChanges:d}=_(e,u);d&&Object.keys(f).length>0?(await c.updateOne(t,f),l.info(`[RealTime-Calc] ✅ Updated ${e}.${t} with calculated fields:`,f)):l.debug(`[RealTime-Calc] No calculated fields to update for ${e}.${t}`)}catch(n){l.error(`[RealTime-Calc] ❌ Error in items.create action for ${e}.${t}:`,n.message)}},100):l.debug(`[RealTime-Calc] No formulas for ${e}, skipping`)):b("quartz_formulas.create")}),t("items.update",async({collection:e,keys:t,payload:r},{schema:o,accountability:i})=>{if(l.info(`[RealTime-Calc] ✏️ items.update ACTION for ${e}, keys:`,t),l.debug("[RealTime-Calc] Payload:",r),"quartz_formulas"!==e)if(0===Object.keys(d).length&&await R(),d[e]&&0!==Object.keys(d[e]).length)for(const c of t){const t=`${e}:${c}`;f.has(t)?(l.debug(`[RealTime-Calc] ⏭️ Skipping self-triggered update for ${t}`),f.delete(t)):setTimeout(async()=>{l.info(`[RealTime-Calc] 🔄 Starting setTimeout for ${e}.${c}`);try{const{ItemsService:u}=n;l.info(`[RealTime-Calc] 📦 Creating ItemsService for ${e}`);const m=new u(e,{database:a,schema:o||("function"==typeof s?await s():void 0),accountability:i});l.info(`[RealTime-Calc] 📖 Reading item ${c} from ${e}`);const g=await m.readOne(c);l.info(`[RealTime-Calc] ✅ Got item data for ${c}:`,JSON.stringify(g)),l.debug(`[RealTime-Calc] Updated item data for ${c}:`,g);const h=Object.keys(r);l.info(`[RealTime-Calc] 🧮 Calling calculateFields for ${e} with changedFields: ${h.join(", ")}`),l.info(`[RealTime-Calc] 📊 formulaConfigs for ${e}:`,JSON.stringify(d[e]));const{updates:T,hasChanges:p}=_(e,g,h);if(l.info(`[RealTime-Calc] 📝 calculateFields returned: hasChanges=${p}, updates=${JSON.stringify(T)}`),l.debug(`[RealTime-Calc] changedFields: ${h.join(", ")}`),l.debug("[RealTime-Calc] calculatedUpdates:",T),p&&Object.keys(T).length>0){const n={};Object.keys(T).forEach(e=>{S(T[e],g[e])||(n[e]=T[e],l.info(`[RealTime-Calc] Calculated field ${e} changed: ${g[e]} → ${T[e]}`))}),Object.keys(n).length>0?(f.add(t),await m.updateOne(c,n),l.info(`[RealTime-Calc] ✅ Updated ${e}.${c} with calculated fields:`,n)):l.debug(`[RealTime-Calc] Calculated fields unchanged for ${e}.${c}`)}else l.debug(`[RealTime-Calc] No calculated fields to update for ${e}.${c}`)}catch(t){l.error(`[RealTime-Calc] ❌ Error in items.update action for ${e}.${c}:`),l.error(t)}},100)}else l.debug(`[RealTime-Calc] No formulas for ${e}, skipping`);else b("quartz_formulas.update")}),t("items.delete",async({collection:e,keys:t})=>{l.info(`[RealTime-Calc] 🗑️ items.delete ACTION for ${e}, keys:`,t),"quartz_formulas"!==e||b("quartz_formulas.delete")}),t("realtime-calc.test-formula",async({formula:e,sampleData:t})=>{const n=i.parser.validate(e,t||{});if(n.valid){const t=i.extractDependencies(e),r=i.isLocal(e);return{valid:!0,result:n.result,fields:t,isLocal:r,message:r?`Formula is valid (local). Result: ${n.result}`:`Formula is valid but requires full engine (uses relations/aggregations). Result: ${n.result}`}}return{valid:!1,error:n.error,message:`Formula error: ${n.error}`}}),t("realtime-calc.reload-formulas",async()=>{try{l.info("[RealTime-Calc] 🔄 Reloading formulas from database (stable)...");const e=await C({attempts:3,settleDelayMs:700,reason:"manual"}),t={collections:Object.keys(d).length,totalFormulas:Object.values(d).reduce((e,t)=>e+Object.keys(t).length,0)};l.info(`[RealTime-Calc] ✅ Reloaded ${t.totalFormulas} formula(s) from ${t.collections} collection(s)`);const n=Object.fromEntries(Object.entries(d).map(([e,t])=>[e,Object.fromEntries(Object.entries(t).map(([e,t])=>[e,t.formula]))]));return l.info(`[RealTime-Calc] 🧾 Formulas content: ${JSON.stringify(n)}`),{success:e,message:`Reloaded ${t.totalFormulas} formula(s) from ${t.collections} collection(s)`,stats:t}}catch(e){return l.error("[RealTime-Calc] ❌ Failed to reload formulas:",e),{success:!1,error:e.message,message:`Failed to reload formulas: ${e.message}`}}}),t("realtime-calc.recalculate-collection",async({collection:e,filter:t=null,batchSize:r=100,dryRun:o=!1},{schema:i,accountability:c})=>{try{if(!e||"string"!=typeof e)throw new Error('Missing or invalid "collection"');if(0===Object.keys(d).length&&await R(),!d[e]||0===Object.keys(d[e]).length)return{success:!0,updated:0,processed:0,total:0,message:`No formulas for collection ${e}`};const{ItemsService:u}=n,f=new u(e,{database:a,schema:i||("function"==typeof s?await s():void 0),accountability:c});let m=0;const g=Math.max(1,Math.min(500,Number(r)||100));let h=0,T=0,p=0;try{const e=await f.readByQuery({filter:t||{},limit:0,meta:"total_count"});e&&e.meta&&"number"==typeof e.meta.total_count&&(p=e.meta.total_count)}catch{}for(;;){const n=await f.readByQuery({filter:t||{},limit:g,offset:m}),r=Array.isArray(n)?n:n?.data||[];if(!r||0===r.length)break;for(const t of r){const{updates:n,hasChanges:r}=_(e,t);if(h++,r&&Object.keys(n).length>0)if(o)T++;else try{await f.updateOne(t.id,n),T++}catch(n){l.error(`[RealTime-Calc] Error updating ${e}.${t.id} during recalc:`,n?.message||n)}}if(m+=r.length,r.length<g)break}return{success:!0,collection:e,processed:h,updated:T,total:p,dryRun:o,message:o?`Dry-run: ${T} item(s) would be updated on ${h} processed.`:`Updated ${T} item(s) on ${h} processed.`}}catch(e){return l.error("[RealTime-Calc] ❌ Failed recalculate-collection:",e?.message||e),{success:!1,error:e?.message||String(e)}}}),t("realtime-calc.get-config",async()=>{const e={};for(const[t,n]of Object.entries(d))e[t]={formulaCount:Object.keys(n).length,fields:Object.keys(n),hasCircularDeps:m[t]?.cycles.length>0,calculationOrder:m[t]?.order||[]};return{collections:Object.keys(d).length,stats:e}}),(async()=>{if(await R()){const e=Object.values(d).reduce((e,t)=>e+Object.keys(t).length,0);l.info("[RealTime-Calc Extension] Loaded successfully"),l.info(`[RealTime-Calc] Monitoring ${Object.keys(d).length} collection(s) with ${e} formula(s)`)}else l.warn("[RealTime-Calc Extension] Started but no formulas loaded (table may not exist yet)")})()};export{p as default};
