class e{constructor(){this.tokenRegex=/(\{\{[a-zA-Z0-9_\.]+\}\}|"(?:[^"\\]|\\.)*"|[0-9]+(?:\.[0-9]+)?|\b(?:IF|COALESCE|ROUND|NULLIF|UPPER|LOWER|CONCAT|AND|OR|NOT|true|false|null)\b|[+\-*\/%()=<>!,]|<=|>=|<>|!=)/gi}compile(e){if(!e)return()=>null;try{const t=this.dslToJavaScript(e),a=this.createHelpers(),r=new Function("data","IF","COALESCE","ROUND","NULLIF","UPPER","LOWER","CONCAT",`\n        return (${t});\n      `);return e=>r(e,a.IF,a.COALESCE,a.ROUND,a.NULLIF,a.UPPER,a.LOWER,a.CONCAT)}catch(e){throw new Error(`Failed to compile formula: ${e.message}`)}}dslToJavaScript(e){let t=e;return t=t.replace(/\{\{([a-zA-Z0-9_]+)\}\}/g,(e,t)=>`(data.${t})`),t=t.replace(/\{\{([a-zA-Z0-9_]+)\.([a-zA-Z0-9_]+)\}\}/g,()=>"null /* cross-collection reference not supported */"),t=t.replace(/\s+AND\s+/gi," && "),t=t.replace(/\s+OR\s+/gi," || "),t=t.replace(/\bNOT\s+/gi,"!"),t=t.replace(/\s*<=\s*/g," __LTE__ "),t=t.replace(/\s*>=\s*/g," __GTE__ "),t=t.replace(/\s*<>\s*/g," __NEQ__ "),t=t.replace(/\s*!=\s*/g," __NEQ__ "),t=t.replace(/\s*<\s*/g," __LT__ "),t=t.replace(/\s*>\s*/g," __GT__ "),t=t.replace(/(?<![=<>!])\s*=\s*(?![=])/g,(e,a)=>{const r=t.substring(0,a),l=(r.match(/"/g)||[]).length,s=(r.match(/'/g)||[]).length;return l%2==1||s%2==1?e:" __EQ__ "}),t=t.replace(/__LTE__/g,"<="),t=t.replace(/__GTE__/g,">="),t=t.replace(/__NEQ__/g,"!=="),t=t.replace(/__LT__/g,"<"),t=t.replace(/__GT__/g,">"),t=t.replace(/__EQ__/g,"==="),t=t.replace(/\bIF\s*\(/gi,"IF("),t=t.replace(/\bCOALESCE\s*\(/gi,"COALESCE("),t=t.replace(/\bROUND\s*\(/gi,"ROUND("),t=t.replace(/\bNULLIF\s*\(/gi,"NULLIF("),t=t.replace(/\bUPPER\s*\(/gi,"UPPER("),t=t.replace(/\bLOWER\s*\(/gi,"LOWER("),t=t.replace(/\bCONCAT\s*\(/gi,"CONCAT("),t}createHelpers(){return{IF:(e,t,a)=>e?t:a,COALESCE:(...e)=>{for(const t of e)if(null!=t)return t;return null},ROUND:(e,t=2)=>{if(null==e||isNaN(e))return null;const a=Math.pow(10,t);return Math.round(e*a)/a},NULLIF:(e,t)=>e===t?null:e,UPPER:e=>e?String(e).toUpperCase():"",LOWER:e=>e?String(e).toLowerCase():"",CONCAT:(...e)=>e.filter(e=>null!=e).map(e=>String(e)).join("")}}extractFields(e){if(!e)return[];const t=[],a=/\{\{([a-zA-Z0-9_]+(?:\.[a-zA-Z0-9_]+)?)\}\}/g;let r;for(;null!==(r=a.exec(e));)t.push(r[1]);return[...new Set(t)]}extractLocalDependencies(e){return this.extractFields(e).filter(e=>!e.includes("."))}isLocalFormula(e){if(!e)return!0;const t=[/\{\{[a-zA-Z0-9_]+\.[a-zA-Z0-9_]+\}\}/,/\bLOOKUP\s*\(/i,/\bPARENT\s*\(/i,/\bCHILDREN\s*\(/i,/\bRELATED\s*\(/i,/\bSUM\s*\(/i,/\bAVG\s*\(/i,/\bCOUNT\s*\(/i,/\bMIN\s*\(/i,/\bMAX\s*\(/i,/\bCOUNT_DISTINCT\s*\(/i];for(const a of t)if(a.test(e))return!1;return!0}validate(e,t={}){try{const a=this.compile(e);return{valid:!0,result:a(t)}}catch(e){return{valid:!1,error:e.message}}}}class t{constructor(t){this.parser=new e,this.logger=t,this.compiledCache=new Map}evaluate(e,t){try{let a=this.compiledCache.get(e);a||(a=this.parser.compile(e),this.compiledCache.set(e,a));const r=a(t);return this.logger?.debug(`Evaluated: ${e} = ${r}`),r}catch(t){throw this.logger?.error(`Error evaluating formula "${e}":`,t.message),t}}clearCache(){this.compiledCache.clear()}getCacheSize(){return this.compiledCache.size}extractDependencies(e){return this.parser.extractLocalDependencies(e)}isLocal(e){return this.parser.isLocalFormula(e)}isLocalFormula(e){return this.isLocal(e)}}class a{constructor(t,a){this.database=t,this.logger=a,this.parser=new e,this.cachedFormulas=null,this.lastLoadTime=null,this.CACHE_TTL=6e4}async loadFormulas(){try{if(this.cachedFormulas&&this.lastLoadTime&&Date.now()-this.lastLoadTime<this.CACHE_TTL)return this.cachedFormulas;const e=await this.database("quartz_formulas").select("*").where("status","published").orderBy("collection_cible","asc").orderBy("sort","asc").orderBy("champ_cible","asc"),t={};for(const a of e){const e=a.collection_cible;if(!e){this.logger?.warn("[FormulaLoader] Missing collection_cible on row id="+a.id);continue}t[e]||(t[e]={});const r=a.champ_cible,l=a.formula;if(!r||!l){this.logger?.warn(`[FormulaLoader] Missing champ_cible or formula for ${e} (id=${a.id})`);continue}const s=this.parser.extractLocalDependencies(l);t[e][r]={formula:l,dependencies:s,isLocal:this.parser.isLocalFormula(l),metadata:{id:a.id,description:a.description,sort:a.sort,updated_at:a.date_updated}}}return this.cachedFormulas=t,this.lastLoadTime=Date.now(),this.logger?.info(`[FormulaLoader] Loaded ${e.length} formula(s) from ${Object.keys(t).length} collection(s)`),t}catch(e){if(this.logger?.error("[FormulaLoader] Error loading formulas:",e.message),e.message.includes("does not exist"))return this.logger?.warn("[FormulaLoader] Table quartz_formulas not found. Using empty config."),{};throw e}}filterLocalFormulas(e){const t={};let a=0;for(const[r,l]of Object.entries(e)){t[r]={};for(const[e,s]of Object.entries(l))s.isLocal?t[r][e]=s:(this.logger?.info(`[FormulaLoader] Skipping non-local formula: ${r}.${e}`),a++);0===Object.keys(t[r]).length&&delete t[r]}return a>0&&this.logger?.info(`[FormulaLoader] Filtered out ${a} non-local formula(s) (require full engine)`),t}async reloadFormulas(){return this.cachedFormulas=null,this.lastLoadTime=null,await this.loadFormulas()}async loadLocalFormulas(){const e=await this.loadFormulas();return this.filterLocalFormulas(e)}}class r{constructor(e){this.logger=e}buildGraph(e){const t={},a=new Set;for(const[r,l]of Object.entries(e))a.add(r),t[r]={formula:l.formula,dependencies:l.dependencies||[],dependents:[]};for(const[e,a]of Object.entries(t))for(const r of a.dependencies)t[r]&&t[r].dependents.push(e);return t}topologicalSort(e){const t=new Set,a=new Set,r=[],l=[],s=(o,n=[])=>{if(a.has(o)){const e=n.indexOf(o),t=n.slice(e).concat(o);return l.push(t),!1}if(t.has(o))return!0;a.add(o),n.push(o);const c=e[o]?.dependencies||[];for(const t of c)if(e[t]&&!s(t,[...n]))return!1;return a.delete(o),t.add(o),r.push(o),!0};for(const a of Object.keys(e))t.has(a)||s(a);return{order:r,cycles:l}}analyze(e){const t=this.buildGraph(e),{order:a,cycles:r}=this.topologicalSort(t),l=this.calculateLevels(t,a);return r.length>0&&(this.logger?.warn(`[DependencyGraph] Detected ${r.length} circular dependency(ies):`),r.forEach(e=>{this.logger?.warn(`  -> ${e.join(" → ")}`)})),this.logger?.debug(`[DependencyGraph] Calculation order: ${a.join(" → ")}`),{order:a,graph:t,cycles:r,levels:l}}calculateLevels(e,t){const a={};for(const r of t){const t=e[r]?.dependencies||[];let l=-1;for(const e of t)void 0!==a[e]&&(l=Math.max(l,a[e]));a[r]=l+1}return a}getAffectedFields(e,t){const a=new Set,r=[...t],l=new Set;for(;r.length>0;){const t=r.shift();if(!l.has(t)){l.add(t);for(const[l,s]of Object.entries(e))s.dependencies.includes(t)&&(a.has(l)||(a.add(l),r.push(l)))}}return Array.from(a)}optimizeCalculationOrder(e,t,a){const r=this.getAffectedFields(e,a),l=new Set([...a,...r]),s=t.filter(e=>l.has(e));return this.logger?.debug(`[DependencyGraph] Changed: ${a.join(", ")}`),this.logger?.debug(`[DependencyGraph] Recalculate: ${s.join(" → ")}`),s}visualize(e){let t="\n=== Dependency Graph ===\n";for(const[a,r]of Object.entries(e))t+=`\n${a}:\n`,r.dependencies.length>0&&(t+=`  depends on: ${r.dependencies.join(", ")}\n`),r.dependents.length>0&&(t+=`  triggers: ${r.dependents.join(", ")}\n`),t+=`  formula: ${r.formula}\n`;return t}}var l=({filter:e,action:l},{services:s,exceptions:o,logger:n,database:c,getSchema:i,env:u})=>{const d=new t(n),f=new a(c,n),m=new r(n);let g={},h={},p=null;function b(e){if(null===e||"object"!=typeof e)return JSON.stringify(e);if(Array.isArray(e))return"["+e.map(b).join(",")+"]";return"{"+Object.keys(e).sort().map(t=>`${JSON.stringify(t)}:${b(e[t])}`).join(",")+"}"}function y(e){try{return b(e)}catch(e){return n.warn("[RealTime-Calc] Could not compute config signature:",e?.message||e),""+Date.now()}}async function C({attempts:e=3,settleDelayMs:t=700,reason:a="unknown"}={}){let r=null,l=null;for(let s=1;s<=e;s++){const o=await f.reloadFormulas(),c=f.filterLocalFormulas(o),i=y(c);if(n.debug(`[RealTime-Calc] Reload attempt ${s}/${e} (reason: ${a}) signature: ${i.substring(0,32)}…`),r&&i===r){n.info(`[RealTime-Calc] 🔒 Reload stabilized on attempt ${s} (reason: ${a})`),l=c;break}r=i,l=c,s<e&&await new Promise(e=>setTimeout(e,t))}return await async function(e){g=e||{},h={};for(const[e,t]of Object.entries(g)){const a=m.analyze(t);h[e]=a,a.cycles.length>0&&n.warn(`[RealTime-Calc] Collection ${e} has circular dependencies!`),n.debug(`[RealTime-Calc] ${e}: ${a.order.length} local formula(s) loaded`)}return!0}(l)}function O(e="unknown"){try{p&&clearTimeout(p),p=setTimeout(async()=>{n.info(`[RealTime-Calc] 🔁 Auto-reloading formulas (reason: ${e})...`);if(await C({attempts:3,settleDelayMs:700,reason:e})){const e=Object.values(g).reduce((e,t)=>e+Object.keys(t).length,0),t=Object.fromEntries(Object.entries(g).map(([e,t])=>[e,Object.keys(t).length])),a=Object.fromEntries(Object.entries(g).map(([e,t])=>[e,Object.keys(t)])),r=Object.fromEntries(Object.entries(g).map(([e,t])=>[e,Object.fromEntries(Object.entries(t).map(([e,t])=>[e,t.formula]))]));n.info(`[RealTime-Calc] ✅ Auto-reload complete: ${e} formula(s) active across ${Object.keys(g).length} collection(s)`),n.info(`[RealTime-Calc] 📦 Reload collections: ${JSON.stringify(t)}`),n.debug(`[RealTime-Calc] 📄 Fields per collection: ${JSON.stringify(a)}`),n.info(`[RealTime-Calc] 🧾 Formulas content: ${JSON.stringify(r)}`)}else n.warn("[RealTime-Calc] ⚠️ Auto-reload failed");p=null},5e3)}catch(e){n.error("[RealTime-Calc] Error scheduling formulas reload:",e?.message||e)}}async function $(){try{g=await f.loadLocalFormulas();for(const[e,t]of Object.entries(g)){const a=m.analyze(t);h[e]=a,a.cycles.length>0&&n.warn(`[RealTime-Calc] Collection ${e} has circular dependencies!`),n.debug(`[RealTime-Calc] ${e}: ${a.order.length} local formula(s) loaded`)}return!0}catch(e){return n.error("[RealTime-Calc] Error loading formulas:",e.message),!1}}function T(e,t,a=null){const r=g[e];if(!r||0===Object.keys(r).length)return{updates:{},hasChanges:!1};const l=h[e],s={};let o=!1,c=l?.order||Object.keys(r);if(a&&a.length>0&&l&&(c=m.optimizeCalculationOrder(l.graph,l.order,a),0===c.length))return n.debug(`[RealTime-Calc] No fields affected by changes in ${e}`),{updates:{},hasChanges:!1};for(const a of c){const l=r[a];try{const r={...t,...s},c=d.evaluate(l.formula,r),i=t[a];R(i,c)?n.debug(`[RealTime-Calc] calc ${e}.${a}: unchanged (${i})`):(s[a]=c,o=!0,n.debug(`[RealTime-Calc] calc ${e}.${a}: ${i} → ${c}`))}catch(t){n.error(`[RealTime-Calc] Error calculating ${e}.${a}:`,t.message)}}return{updates:s,hasChanges:o}}function R(e,t){if(e===t)return!0;if(null==e&&null==t)return!0;if(null==e||null==t)return!1;if("number"==typeof e&&"number"==typeof t){if(isNaN(e)&&isNaN(t))return!0;const a=1e-7;return Math.abs(e-t)<a}return"boolean"==typeof e&&"boolean"==typeof t?e===t:("string"==typeof e||"string"==typeof t)&&String(e)===String(t)}l("items.create",async({collection:e,key:t,payload:a},{schema:r,accountability:l})=>{n.info(`[RealTime-Calc] ✨ items.create ACTION for ${e}.${t}`),"quartz_formulas"!==e?(0===Object.keys(g).length&&await $(),g[e]&&0!==Object.keys(g[e]).length?setTimeout(async()=>{try{const{ItemsService:a}=s,o=new a(e,{database:c,schema:r||("function"==typeof i?await i():void 0),accountability:l}),u=await o.readOne(t);n.debug("[RealTime-Calc] Created item data:",u);const{updates:d,hasChanges:f}=T(e,u);f&&Object.keys(d).length>0?(await o.updateOne(t,d),n.info(`[RealTime-Calc] ✅ Updated ${e}.${t} with calculated fields:`,d)):n.debug(`[RealTime-Calc] No calculated fields to update for ${e}.${t}`)}catch(a){n.error(`[RealTime-Calc] ❌ Error in items.create action for ${e}.${t}:`,a.message)}},100):n.debug(`[RealTime-Calc] No formulas for ${e}, skipping`)):O("quartz_formulas.create")}),l("items.update",async({collection:e,keys:t,payload:a},{schema:r,accountability:l})=>{if(n.info(`[RealTime-Calc] ✏️ items.update ACTION for ${e}, keys:`,t),n.debug("[RealTime-Calc] Payload:",a),"quartz_formulas"!==e)if(0===Object.keys(g).length&&await $(),g[e]&&0!==Object.keys(g[e]).length)for(const o of t)setTimeout(async()=>{n.info(`[RealTime-Calc] 🔄 Starting setTimeout for ${e}.${o}`);try{const{ItemsService:t}=s;n.info(`[RealTime-Calc] 📦 Creating ItemsService for ${e}`);const u=new t(e,{database:c,schema:r||("function"==typeof i?await i():void 0),accountability:l});n.info(`[RealTime-Calc] 📖 Reading item ${o} from ${e}`);const d=await u.readOne(o);n.info(`[RealTime-Calc] ✅ Got item data for ${o}:`,JSON.stringify(d)),n.debug(`[RealTime-Calc] Updated item data for ${o}:`,d);const f=Object.keys(a);n.info(`[RealTime-Calc] 🧮 Calling calculateFields for ${e} with changedFields: ${f.join(", ")}`),n.info(`[RealTime-Calc] 📊 formulaConfigs for ${e}:`,JSON.stringify(g[e]));const{updates:m,hasChanges:h}=T(e,d,f);if(n.info(`[RealTime-Calc] 📝 calculateFields returned: hasChanges=${h}, updates=${JSON.stringify(m)}`),n.debug(`[RealTime-Calc] changedFields: ${f.join(", ")}`),n.debug("[RealTime-Calc] calculatedUpdates:",m),h&&Object.keys(m).length>0){const t={};Object.keys(m).forEach(e=>{R(m[e],d[e])||(t[e]=m[e],n.info(`[RealTime-Calc] Calculated field ${e} changed: ${d[e]} → ${m[e]}`))}),Object.keys(t).length>0?(await u.updateOne(o,t),n.info(`[RealTime-Calc] ✅ Updated ${e}.${o} with calculated fields:`,t)):n.debug(`[RealTime-Calc] Calculated fields unchanged for ${e}.${o}`)}else n.debug(`[RealTime-Calc] No calculated fields to update for ${e}.${o}`)}catch(t){n.error(`[RealTime-Calc] ❌ Error in items.update action for ${e}.${o}:`),n.error(t)}},100);else n.debug(`[RealTime-Calc] No formulas for ${e}, skipping`);else O("quartz_formulas.update")}),l("items.delete",async({collection:e,keys:t})=>{n.info(`[RealTime-Calc] 🗑️ items.delete ACTION for ${e}, keys:`,t),"quartz_formulas"!==e||O("quartz_formulas.delete")}),l("realtime-calc.test-formula",async({formula:e,sampleData:t})=>{const a=d.parser.validate(e,t||{});if(a.valid){const t=d.extractDependencies(e),r=d.isLocal(e);return{valid:!0,result:a.result,fields:t,isLocal:r,message:r?`Formula is valid (local). Result: ${a.result}`:`Formula is valid but requires full engine (uses relations/aggregations). Result: ${a.result}`}}return{valid:!1,error:a.error,message:`Formula error: ${a.error}`}}),l("realtime-calc.reload-formulas",async()=>{try{n.info("[RealTime-Calc] 🔄 Reloading formulas from database (stable)...");const e=await C({attempts:3,settleDelayMs:700,reason:"manual"}),t={collections:Object.keys(g).length,totalFormulas:Object.values(g).reduce((e,t)=>e+Object.keys(t).length,0)};n.info(`[RealTime-Calc] ✅ Reloaded ${t.totalFormulas} formula(s) from ${t.collections} collection(s)`);const a=Object.fromEntries(Object.entries(g).map(([e,t])=>[e,Object.fromEntries(Object.entries(t).map(([e,t])=>[e,t.formula]))]));return n.info(`[RealTime-Calc] 🧾 Formulas content: ${JSON.stringify(a)}`),{success:e,message:`Reloaded ${t.totalFormulas} formula(s) from ${t.collections} collection(s)`,stats:t}}catch(e){return n.error("[RealTime-Calc] ❌ Failed to reload formulas:",e),{success:!1,error:e.message,message:`Failed to reload formulas: ${e.message}`}}}),l("realtime-calc.recalculate-collection",async({collection:e,filter:t=null,batchSize:a=100,dryRun:r=!1},{schema:l,accountability:o})=>{try{if(!e||"string"!=typeof e)throw new Error('Missing or invalid "collection"');if(0===Object.keys(g).length&&await $(),!g[e]||0===Object.keys(g[e]).length)return{success:!0,updated:0,processed:0,total:0,message:`No formulas for collection ${e}`};const{ItemsService:u}=s,d=new u(e,{database:c,schema:l||("function"==typeof i?await i():void 0),accountability:o});let f=0;const m=Math.max(1,Math.min(500,Number(a)||100));let h=0,p=0,b=0;try{const e=await d.readByQuery({filter:t||{},limit:0,meta:"total_count"});e&&e.meta&&"number"==typeof e.meta.total_count&&(b=e.meta.total_count)}catch{}for(;;){const a=await d.readByQuery({filter:t||{},limit:m,offset:f}),l=Array.isArray(a)?a:a?.data||[];if(!l||0===l.length)break;for(const t of l){const{updates:a,hasChanges:l}=T(e,t);if(h++,l&&Object.keys(a).length>0)if(r)p++;else try{await d.updateOne(t.id,a),p++}catch(a){n.error(`[RealTime-Calc] Error updating ${e}.${t.id} during recalc:`,a?.message||a)}}if(f+=l.length,l.length<m)break}return{success:!0,collection:e,processed:h,updated:p,total:b,dryRun:r,message:r?`Dry-run: ${p} item(s) would be updated on ${h} processed.`:`Updated ${p} item(s) on ${h} processed.`}}catch(e){return n.error("[RealTime-Calc] ❌ Failed recalculate-collection:",e?.message||e),{success:!1,error:e?.message||String(e)}}}),l("realtime-calc.get-config",async()=>{const e={};for(const[t,a]of Object.entries(g))e[t]={formulaCount:Object.keys(a).length,fields:Object.keys(a),hasCircularDeps:h[t]?.cycles.length>0,calculationOrder:h[t]?.order||[]};return{collections:Object.keys(g).length,stats:e}}),(async()=>{if(await $()){const e=Object.values(g).reduce((e,t)=>e+Object.keys(t).length,0);n.info("[RealTime-Calc Extension] Loaded successfully"),n.info(`[RealTime-Calc] Monitoring ${Object.keys(g).length} collection(s) with ${e} formula(s)`)}else n.warn("[RealTime-Calc Extension] Started but no formulas loaded (table may not exist yet)")})()};export{l as default};
