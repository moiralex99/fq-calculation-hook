const e={millisecond:1,second:1e3,minute:6e4,hour:36e5,day:864e5,week:6048e5},t=new Set(["day","week","month","quarter","year"]),r=new Set(["month","quarter","year"]);function n(e){return String(e||"").toLowerCase()}function a(e){return new Date(e.getTime())}function l(e){if(null==e||""===e)return null;if(e instanceof Date)return a(e);const t=new Date(e);return Number.isNaN(t.getTime())?null:t}function s(e){if(!e)return null;return`${e.getFullYear()}-${String(e.getMonth()+1).padStart(2,"0")}-${String(e.getDate()).padStart(2,"0")}`}function o(e){return e?e.toISOString():null}function c(e,t){const r=a(e),n=r.getMonth()+t;r.setDate(1),r.setMonth(n);const l=e.getDate(),s=new Date(r.getFullYear(),r.getMonth()+1,0).getDate();return r.setDate(Math.min(l,s)),r}function i(t,r,a){const l=n(r);if(!Number.isFinite(a))return null;if("quarter"===l)return c(t,3*a);if("year"===l)return c(t,12*a);if("month"===l)return c(t,a);const s=e[l];return s?new Date(t.getTime()+a*s):null}function u(e,t){const r=n(t),l=a(e);switch(r){case"day":return l.setHours(0,0,0,0),l;case"week":{const e=(l.getDay()+6)%7;return l.setHours(0,0,0,0),l.setDate(l.getDate()-e),l}case"month":return l.setHours(0,0,0,0),l.setDate(1),l;case"quarter":{l.setHours(0,0,0,0);const e=3*Math.floor(l.getMonth()/3);return l.setMonth(e,1),l}case"year":return l.setHours(0,0,0,0),l.setMonth(0,1),l;default:return l}}function d(e){if(null==e||""===e)return null;const t=Number(e);return Number.isNaN(t)?null:t}function f(e,t,{strict:r=!0}={}){const n=String(t||"").toLowerCase();if(null==e)return null;const a=e=>{if(r)throw new Error(e);return null};switch(n){case"string":case"text":return String(e);case"int":case"integer":case"bigint":{const t=d(e);return null==t?a("Invalid integer cast"):Math.trunc(t)}case"float":case"double":case"decimal":case"numeric":return d(e)??a("Invalid decimal cast");case"bool":case"boolean":{if("boolean"==typeof e)return e;if("number"==typeof e)return 0!==e;const t=String(e).trim().toLowerCase();return!!["true","1","yes","y"].includes(t)||!["false","0","no","n"].includes(t)&&a("Invalid boolean cast")}case"date":{const t=l(e);return t?s(t):a("Invalid date cast")}case"datetime":case"timestamp":{const t=l(e);return t?o(t):a("Invalid datetime cast")}default:return a(`Unsupported cast type: ${t}`)}}class g{constructor(){this.tokenRegex=/(\{\{[a-zA-Z0-9_\.]+\}\}|"(?:[^"\\]|\\.)*"|[0-9]+(?:\.[0-9]+)?|\b(?:IF|CASE_WHEN|COALESCE|ROUND|ABS|CEIL|FLOOR|NULLIF|IS_NULL|IN|BETWEEN|EQ|NE|LT|LTE|GT|GTE|DATE_DIFF|DATEDIFF|DATE_ADD|DATE_TRUNC|EXTRACT|START_OF|END_OF|MAKE_DATE|TODAY|NOW|UPPER|LOWER|LENGTH|LEFT|RIGHT|SUBSTR|SUBSTRING|TRIM|LTRIM|RTRIM|REPLACE|REGEX_MATCH|REGEX_EXTRACT|REGEX_REPLACE|CONCAT|CONCAT_WS|CAST|TRY_CAST|ADD|SUB|MUL|DIV|MOD|NEGATE|POWER|SQRT|SIGN|GREATEST|LEAST|AND|OR|NOT|true|false|null)\b|[+\-*\/%()=<>!,]|<=|>=|<>|!=)/gi}compile(e){if(!e)return()=>null;try{const t=this.dslToJavaScript(e),r=this.createHelpers(),n=Object.entries(r),a=n.map(([e])=>e),l=new Function("data",...a,`\n        return (${t});\n      `);return e=>{const t=n.map(([,e])=>e);return l(e,...t)}}catch(e){throw new Error(`Failed to compile formula: ${e.message}`)}}dslToJavaScript(e){let t=e;t=t.replace(/\{\{([a-zA-Z0-9_]+)\}\}/g,(e,t)=>`(data.${t})`),t=t.replace(/\{\{([a-zA-Z0-9_]+)\.([a-zA-Z0-9_]+)\}\}/g,()=>"null /* cross-collection reference not supported */"),t=t.replace(/\s+AND\s+/gi," && "),t=t.replace(/\s+OR\s+/gi," || "),t=t.replace(/\bNOT\s+/gi,"!"),t=t.replace(/\s*<=\s*/g," __LTE__ "),t=t.replace(/\s*>=\s*/g," __GTE__ "),t=t.replace(/\s*<>\s*/g," __NEQ__ "),t=t.replace(/\s*!=\s*/g," __NEQ__ "),t=t.replace(/\s*<\s*/g," __LT__ "),t=t.replace(/\s*>\s*/g," __GT__ "),t=t.replace(/(?<![=<>!])\s*=\s*(?![=])/g,(e,r)=>{const n=t.substring(0,r),a=(n.match(/"/g)||[]).length,l=(n.match(/'/g)||[]).length;return a%2==1||l%2==1?e:" __EQ__ "}),t=t.replace(/__LTE__/g,"<="),t=t.replace(/__GTE__/g,">="),t=t.replace(/__NEQ__/g,"!=="),t=t.replace(/__LT__/g,"<"),t=t.replace(/__GT__/g,">"),t=t.replace(/__EQ__/g,"==="),t=t.replace(/\band\s*\(/gi,"AND_FUNC("),t=t.replace(/\bor\s*\(/gi,"OR_FUNC("),t=t.replace(/\bnot\s*\(/gi,"NOT_FUNC(");const r=["IF","CASE_WHEN","COALESCE","ROUND","ABS","CEIL","FLOOR","NULLIF","IS_NULL","IN","BETWEEN","EQ","NE","LT","LTE","GT","GTE","DATE_DIFF","DATEDIFF","DATE_ADD","DATE_TRUNC","EXTRACT","START_OF","END_OF","MAKE_DATE","TODAY","NOW","UPPER","LOWER","LENGTH","LEFT","RIGHT","SUBSTR","SUBSTRING","TRIM","LTRIM","RTRIM","REPLACE","REGEX_MATCH","REGEX_EXTRACT","REGEX_REPLACE","CONCAT","CONCAT_WS","CAST","TRY_CAST","ADD","SUB","MUL","DIV","MOD","NEGATE","POWER","SQRT","SIGN","GREATEST","LEAST"];for(const e of r){const r=new RegExp(`\\b${e}\\s*\\(`,"gi");t=t.replace(r,`${e}(`)}return t}createHelpers(){const c={IF:(e,t,r)=>e?t:r,CASE_WHEN:(...e)=>{const t=e.length;for(let r=0;r<t-1;r+=2)if(e[r])return e[r+1];return t%2==1?e[t-1]:null},COALESCE:(...e)=>{for(const t of e)if(null!=t&&void 0!==t)return t;return null},ROUND:(e,t=2)=>{const r=d(e);if(null==r)return null;const n=10**(t??0);return Math.round(r*n)/n},ABS:e=>{const t=d(e);return null==t?null:Math.abs(t)},CEIL:e=>{const t=d(e);return null==t?null:Math.ceil(t)},FLOOR:e=>{const t=d(e);return null==t?null:Math.floor(t)},NULLIF:(e,t)=>e===t?null:e,IS_NULL:e=>null==e,IN:(e,...t)=>{for(const r of t)if(Array.isArray(r)){if(r.includes(e))return!0}else if(e===r)return!0;return!1},BETWEEN:(e,t,r)=>{if(null==e||null==t||null==r)return!1;const n=l(e),a=l(t),s=l(r);if(n&&a&&s){const e=n.getTime();return e>=a.getTime()&&e<=s.getTime()}const o=d(e),c=d(t),i=d(r);return null!=o&&null!=c&&null!=i?o>=c&&o<=i:e>=t&&e<=r},EQ:(e,t)=>e===t,NE:(e,t)=>e!==t,LT:(e,t)=>{const r=d(e),n=d(t);if(null!=r&&null!=n)return r<n;const a=l(e),s=l(t);return a&&s?a.getTime()<s.getTime():e<t},LTE:(e,t)=>{const r=d(e),n=d(t);if(null!=r&&null!=n)return r<=n;const a=l(e),s=l(t);return a&&s?a.getTime()<=s.getTime():e<=t},GT:(e,t)=>{const r=d(e),n=d(t);if(null!=r&&null!=n)return r>n;const a=l(e),s=l(t);return a&&s?a.getTime()>s.getTime():e>t},GTE:(e,t)=>{const r=d(e),n=d(t);if(null!=r&&null!=n)return r>=n;const a=l(e),s=l(t);return a&&s?a.getTime()>=s.getTime():e>=t}};return c.DATE_DIFF=(t,a,s)=>function(t,a,s){const o=n(t),c=l(a),i=l(s);if(!c||!i)return null;const u=i.getTime()-c.getTime();if(r.has(o)){const e=12*(i.getFullYear()-c.getFullYear())+(i.getMonth()-c.getMonth()),t=i.getDate()-c.getDate();let r=e;if(u>=0&&t<0?r-=1:u<0&&t>0&&(r+=1),"month"===o)return r;if("quarter"===o)return Math.trunc(r/3);if("year"===o)return Math.trunc(r/12)}const d=e[o];return d?Math.trunc(u/d):null}(t,a,s),c.DATEDIFF=(e,t,r)=>c.DATE_DIFF(r,t,e),c.DATE_ADD=(e,r,a)=>{const c=l(a),u=d(r);if(!c||null==u)return null;const f=i(c,e,u);return f?t.has(n(e))?s(f):o(f):null},c.DATE_TRUNC=(e,r)=>{const a=l(r);if(!a)return null;const c=u(a,e);return t.has(n(e))?s(c):o(c)},c.START_OF=(e,t)=>c.DATE_TRUNC(e,t),c.END_OF=(e,r)=>{const c=l(r);if(!c)return null;const d=function(e,t){const r=n(t);if("day"===r){const t=a(e);return t.setHours(23,59,59,999),t}const l=u(e,r),s=i(l,r,1);return s?(s.setMilliseconds(s.getMilliseconds()-1),s):l}(c,e);return t.has(n(e))?s(d):o(d)},c.MAKE_DATE=(e,t,r)=>{const n=d(e),a=d(t),l=d(r);if(null==n||null==a||null==l)return null;const o=new Date(Date.UTC(n,a-1,l));return Number.isNaN(o.getTime())?null:s(o)},c.TODAY=()=>s(new Date),c.NOW=()=>o(new Date),c.EXTRACT=(e,t)=>{const r=l(t);if(!r)return null;switch(n(e)){case"year":return r.getFullYear();case"month":return r.getMonth()+1;case"day":case"day_of_month":return r.getDate();case"hour":return r.getHours();case"minute":return r.getMinutes();case"second":return r.getSeconds();case"quarter":return Math.floor(r.getMonth()/3)+1;case"week":{const e=new Date(Date.UTC(r.getFullYear(),r.getMonth(),r.getDate())),t=e.getUTCDay()||7;e.setUTCDate(e.getUTCDate()+4-t);const n=new Date(Date.UTC(e.getUTCFullYear(),0,1));return Math.ceil(((e-n)/864e5+1)/7)}case"dow":case"day_of_week":return(r.getDay()+6)%7+1;default:return null}},c.UPPER=e=>null!=e?String(e).toUpperCase():"",c.LOWER=e=>null!=e?String(e).toLowerCase():"",c.LENGTH=e=>null!=e?String(e).length:0,c.LEFT=(e,t)=>{const r=null!=e?String(e):"",n=d(t)??0;return r.slice(0,Math.max(0,n))},c.RIGHT=(e,t)=>{const r=null!=e?String(e):"",n=d(t)??0;return 0===n?"":r.slice(-Math.max(0,n))},c.SUBSTR=(e,t,r)=>{const n=null!=e?String(e):"",a=d(t)??0;if(null==r)return n.substring(a);const l=d(r)??0;return n.substring(a,a+l)},c.SUBSTRING=c.SUBSTR,c.TRIM=e=>null!=e?String(e).trim():"",c.LTRIM=e=>null!=e?String(e).trimStart():"",c.RTRIM=e=>null!=e?String(e).trimEnd():"",c.REPLACE=(e,t,r)=>{if(null==e)return"";const n=String(e),a=null!=t?String(t):"",l=null!=r?String(r):"";return""===a?n:n.split(a).join(l)},c.REGEX_MATCH=(e,t)=>{if(null==e||null==t)return!1;return new RegExp(t).test(String(e))},c.REGEX_EXTRACT=(e,t,r=1)=>{if(null==e||null==t)return null;const n=new RegExp(t).exec(String(e));if(!n)return null;const a=null==r?1:Number(r);return n[Number.isNaN(a)?1:a]??null},c.REGEX_REPLACE=(e,t,r="")=>{if(null==e||null==t)return null;const n=new RegExp(t,"g");return String(e).replace(n,r)},c.CONCAT=(...e)=>e.filter(e=>null!=e&&void 0!==e).map(e=>String(e)).join(""),c.CONCAT_WS=(e,...t)=>{const r=null!=e?String(e):"";return t.filter(e=>null!=e&&void 0!==e).map(e=>String(e)).join(r)},c.CAST=(e,t)=>f(e,t,{strict:!0}),c.TRY_CAST=(e,t)=>f(e,t,{strict:!1}),c.ADD=(...e)=>{if(!e.length)return 0;let t=0;for(const r of e){t+=d(r)??0}return t},c.SUB=(...e)=>{if(!e.length)return null;const t=d(e[0]);if(null==t)return null;let r=t;for(let t=1;t<e.length;t++){r-=d(e[t])??0}return r},c.MUL=(...e)=>{if(!e.length)return null;let t=1;for(const r of e){const e=d(r);if(null==e)return null;t*=e}return t},c.DIV=(e,t)=>{const r=d(e),n=d(t);return null==r||null==n||0===n?null:r/n},c.MOD=(e,t)=>{const r=d(e),n=d(t);return null==r||null==n||0===n?null:r%n},c.NEGATE=e=>{const t=d(e);return null==t?null:-t},c.POWER=(e,t)=>{const r=d(e),n=d(t);return null==r||null==n?null:Math.pow(r,n)},c.SQRT=e=>{const t=d(e);return null==t||t<0?null:Math.sqrt(t)},c.SIGN=e=>{const t=d(e);return null==t?null:t>0?1:t<0?-1:0},c.GREATEST=(...e)=>{const t=e.map(d).filter(e=>null!=e);return t.length?Math.max(...t):null},c.LEAST=(...e)=>{const t=e.map(d).filter(e=>null!=e);return t.length?Math.min(...t):null},c.AND_FUNC=(...e)=>e.every(e=>Boolean(e)),c.OR_FUNC=(...e)=>e.some(e=>Boolean(e)),c.NOT_FUNC=e=>!Boolean(e),c}extractFields(e){if(!e)return[];const t=[],r=/\{\{([a-zA-Z0-9_]+(?:\.[a-zA-Z0-9_]+)?)\}\}/g;let n;for(;null!==(n=r.exec(e));)t.push(n[1]);return[...new Set(t)]}extractLocalDependencies(e){return this.extractFields(e).filter(e=>!e.includes("."))}isLocalFormula(e){if(!e)return!0;const t=[/\{\{[a-zA-Z0-9_]+\.[a-zA-Z0-9_]+\}\}/,/\bLOOKUP\s*\(/i,/\bPARENT\s*\(/i,/\bCHILDREN\s*\(/i,/\bRELATED\s*\(/i,/\bSUM\s*\(/i,/\bAVG\s*\(/i,/\bCOUNT\s*\(/i,/\bMIN\s*\(/i,/\bMAX\s*\(/i,/\bCOUNT_DISTINCT\s*\(/i];for(const r of t)if(r.test(e))return!1;return!0}validate(e,t={}){try{const r=this.compile(e);return{valid:!0,result:r(t)}}catch(e){return{valid:!1,error:e.message}}}}class m{constructor(e){this.parser=new g,this.logger=e,this.compiledCache=new Map}evaluate(e,t){try{let r=this.compiledCache.get(e);r||(r=this.parser.compile(e),this.compiledCache.set(e,r));const n=r(t);return this.logger?.debug(`Evaluated: ${e} = ${n}`),n}catch(t){throw this.logger?.error(`Error evaluating formula "${e}":`,t.message),t}}clearCache(){this.compiledCache.clear()}getCacheSize(){return this.compiledCache.size}extractDependencies(e){return this.parser.extractLocalDependencies(e)}isLocal(e){return this.parser.isLocalFormula(e)}isLocalFormula(e){return this.isLocal(e)}}class h{constructor(e,t){this.database=e,this.logger=t,this.parser=new g,this.cachedFormulas=null,this.lastLoadTime=null,this.CACHE_TTL=6e4}async loadFormulas(){try{if(this.cachedFormulas&&this.lastLoadTime&&Date.now()-this.lastLoadTime<this.CACHE_TTL)return this.cachedFormulas;const e=await this.database("quartz_formulas").select("*").where("status","published").orderBy("collection_cible","asc").orderBy("sort","asc").orderBy("champ_cible","asc"),t={};for(const r of e){const e=r.collection_cible;if(!e){this.logger?.warn("[FormulaLoader] Missing collection_cible on row id="+r.id);continue}t[e]||(t[e]={});const n=r.champ_cible,a=r.formula;if(!n||!a){this.logger?.warn(`[FormulaLoader] Missing champ_cible or formula for ${e} (id=${r.id})`);continue}const l=this.parser.extractLocalDependencies(a);t[e][n]={formula:a,dependencies:l,isLocal:this.parser.isLocalFormula(a),metadata:{id:r.id,description:r.description,sort:r.sort,updated_at:r.date_updated}}}return this.cachedFormulas=t,this.lastLoadTime=Date.now(),this.logger?.info(`[FormulaLoader] Loaded ${e.length} formula(s) from ${Object.keys(t).length} collection(s)`),t}catch(e){if(this.logger?.error("[FormulaLoader] Error loading formulas:",e.message),e.message.includes("does not exist"))return this.logger?.warn("[FormulaLoader] Table quartz_formulas not found. Using empty config."),{};throw e}}filterLocalFormulas(e){const t={};let r=0;for(const[n,a]of Object.entries(e)){t[n]={};for(const[e,l]of Object.entries(a))l.isLocal?t[n][e]=l:(this.logger?.info(`[FormulaLoader] Skipping non-local formula: ${n}.${e}`),r++);0===Object.keys(t[n]).length&&delete t[n]}return r>0&&this.logger?.info(`[FormulaLoader] Filtered out ${r} non-local formula(s) (require full engine)`),t}async reloadFormulas(){return this.cachedFormulas=null,this.lastLoadTime=null,await this.loadFormulas()}async loadLocalFormulas(){const e=await this.loadFormulas();return this.filterLocalFormulas(e)}}class T{constructor(e){this.logger=e}buildGraph(e){const t={},r=new Set;for(const[n,a]of Object.entries(e))r.add(n),t[n]={formula:a.formula,dependencies:a.dependencies||[],dependents:[]};for(const[e,r]of Object.entries(t))for(const n of r.dependencies)t[n]&&t[n].dependents.push(e);return t}topologicalSort(e){const t=new Set,r=new Set,n=[],a=[],l=(s,o=[])=>{if(r.has(s)){const e=o.indexOf(s),t=o.slice(e).concat(s);return a.push(t),!1}if(t.has(s))return!0;r.add(s),o.push(s);const c=e[s]?.dependencies||[];for(const t of c)if(e[t]&&!l(t,[...o]))return!1;return r.delete(s),t.add(s),n.push(s),!0};for(const r of Object.keys(e))t.has(r)||l(r);return{order:n,cycles:a}}analyze(e){const t=this.buildGraph(e),{order:r,cycles:n}=this.topologicalSort(t),a=this.calculateLevels(t,r);return n.length>0&&(this.logger?.warn(`[DependencyGraph] Detected ${n.length} circular dependency(ies):`),n.forEach(e=>{this.logger?.warn(`  -> ${e.join(" → ")}`)})),this.logger?.debug(`[DependencyGraph] Calculation order: ${r.join(" → ")}`),{order:r,graph:t,cycles:n,levels:a}}calculateLevels(e,t){const r={};for(const n of t){const t=e[n]?.dependencies||[];let a=-1;for(const e of t)void 0!==r[e]&&(a=Math.max(a,r[e]));r[n]=a+1}return r}getAffectedFields(e,t){const r=new Set,n=[...t],a=new Set;for(;n.length>0;){const t=n.shift();if(!a.has(t)){a.add(t);for(const[a,l]of Object.entries(e))l.dependencies.includes(t)&&(r.has(a)||(r.add(a),n.push(a)))}}return Array.from(r)}optimizeCalculationOrder(e,t,r){const n=this.getAffectedFields(e,r),a=new Set([...r,...n]),l=t.filter(e=>a.has(e));return this.logger?.debug(`[DependencyGraph] Changed: ${r.join(", ")}`),this.logger?.debug(`[DependencyGraph] Recalculate: ${l.join(" → ")}`),l}visualize(e){let t="\n=== Dependency Graph ===\n";for(const[r,n]of Object.entries(e))t+=`\n${r}:\n`,n.dependencies.length>0&&(t+=`  depends on: ${n.dependencies.join(", ")}\n`),n.dependents.length>0&&(t+=`  triggers: ${n.dependents.join(", ")}\n`),t+=`  formula: ${n.formula}\n`;return t}}var p=({filter:e,action:t},{services:r,exceptions:n,logger:a,database:l,getSchema:s,env:o})=>{const c=new m(a),i=new h(l,a),u=new T(a);let d={},f={},g=null;function p(e){if(null===e||"object"!=typeof e)return JSON.stringify(e);if(Array.isArray(e))return"["+e.map(p).join(",")+"]";return"{"+Object.keys(e).sort().map(t=>`${JSON.stringify(t)}:${p(e[t])}`).join(",")+"}"}function E(e){try{return p(e)}catch(e){return a.warn("[RealTime-Calc] Could not compute config signature:",e?.message||e),""+Date.now()}}async function C({attempts:e=3,settleDelayMs:t=700,reason:r="unknown"}={}){let n=null,l=null;for(let s=1;s<=e;s++){const o=await i.reloadFormulas(),c=i.filterLocalFormulas(o),u=E(c);if(a.debug(`[RealTime-Calc] Reload attempt ${s}/${e} (reason: ${r}) signature: ${u.substring(0,32)}…`),n&&u===n){a.info(`[RealTime-Calc] 🔒 Reload stabilized on attempt ${s} (reason: ${r})`),l=c;break}n=u,l=c,s<e&&await new Promise(e=>setTimeout(e,t))}return await async function(e){d=e||{},f={};for(const[e,t]of Object.entries(d)){const r=u.analyze(t);f[e]=r,r.cycles.length>0&&a.warn(`[RealTime-Calc] Collection ${e} has circular dependencies!`),a.debug(`[RealTime-Calc] ${e}: ${r.order.length} local formula(s) loaded`)}return!0}(l)}function y(e="unknown"){try{g&&clearTimeout(g),g=setTimeout(async()=>{a.info(`[RealTime-Calc] 🔁 Auto-reloading formulas (reason: ${e})...`);if(await C({attempts:3,settleDelayMs:700,reason:e})){const e=Object.values(d).reduce((e,t)=>e+Object.keys(t).length,0),t=Object.fromEntries(Object.entries(d).map(([e,t])=>[e,Object.keys(t).length])),r=Object.fromEntries(Object.entries(d).map(([e,t])=>[e,Object.keys(t)])),n=Object.fromEntries(Object.entries(d).map(([e,t])=>[e,Object.fromEntries(Object.entries(t).map(([e,t])=>[e,t.formula]))]));a.info(`[RealTime-Calc] ✅ Auto-reload complete: ${e} formula(s) active across ${Object.keys(d).length} collection(s)`),a.info(`[RealTime-Calc] 📦 Reload collections: ${JSON.stringify(t)}`),a.debug(`[RealTime-Calc] 📄 Fields per collection: ${JSON.stringify(r)}`),a.info(`[RealTime-Calc] 🧾 Formulas content: ${JSON.stringify(n)}`)}else a.warn("[RealTime-Calc] ⚠️ Auto-reload failed");g=null},5e3)}catch(e){a.error("[RealTime-Calc] Error scheduling formulas reload:",e?.message||e)}}async function b(){try{d=await i.loadLocalFormulas();for(const[e,t]of Object.entries(d)){const r=u.analyze(t);f[e]=r,r.cycles.length>0&&a.warn(`[RealTime-Calc] Collection ${e} has circular dependencies!`),a.debug(`[RealTime-Calc] ${e}: ${r.order.length} local formula(s) loaded`)}return!0}catch(e){return a.error("[RealTime-Calc] Error loading formulas:",e.message),!1}}function R(e,t,r=null){const n=d[e];if(!n||0===Object.keys(n).length)return{updates:{},hasChanges:!1};const l=f[e],s={};let o=!1,i=l?.order||Object.keys(n);if(r&&r.length>0&&l&&(i=u.optimizeCalculationOrder(l.graph,l.order,r),0===i.length))return a.debug(`[RealTime-Calc] No fields affected by changes in ${e}`),{updates:{},hasChanges:!1};for(const r of i){const l=n[r];try{const n={...t,...s},i=c.evaluate(l.formula,n),u=t[r];_(u,i)?a.debug(`[RealTime-Calc] calc ${e}.${r}: unchanged (${u})`):(s[r]=i,o=!0,a.debug(`[RealTime-Calc] calc ${e}.${r}: ${u} → ${i}`))}catch(t){a.error(`[RealTime-Calc] Error calculating ${e}.${r}:`,t.message)}}return{updates:s,hasChanges:o}}function _(e,t){if(e===t)return!0;if(null==e&&null==t)return!0;if(null==e||null==t)return!1;if("number"==typeof e&&"number"==typeof t){if(isNaN(e)&&isNaN(t))return!0;const r=1e-7;return Math.abs(e-t)<r}return"boolean"==typeof e&&"boolean"==typeof t?e===t:("string"==typeof e||"string"==typeof t)&&String(e)===String(t)}t("items.create",async({collection:e,key:t,payload:n},{schema:o,accountability:c})=>{a.info(`[RealTime-Calc] ✨ items.create ACTION for ${e}.${t}`),"quartz_formulas"!==e?(0===Object.keys(d).length&&await b(),d[e]&&0!==Object.keys(d[e]).length?setTimeout(async()=>{try{const{ItemsService:n}=r,i=new n(e,{database:l,schema:o||("function"==typeof s?await s():void 0),accountability:c}),u=await i.readOne(t);a.debug("[RealTime-Calc] Created item data:",u);const{updates:d,hasChanges:f}=R(e,u);f&&Object.keys(d).length>0?(await i.updateOne(t,d),a.info(`[RealTime-Calc] ✅ Updated ${e}.${t} with calculated fields:`,d)):a.debug(`[RealTime-Calc] No calculated fields to update for ${e}.${t}`)}catch(r){a.error(`[RealTime-Calc] ❌ Error in items.create action for ${e}.${t}:`,r.message)}},100):a.debug(`[RealTime-Calc] No formulas for ${e}, skipping`)):y("quartz_formulas.create")}),t("items.update",async({collection:e,keys:t,payload:n},{schema:o,accountability:c})=>{if(a.info(`[RealTime-Calc] ✏️ items.update ACTION for ${e}, keys:`,t),a.debug("[RealTime-Calc] Payload:",n),"quartz_formulas"!==e)if(0===Object.keys(d).length&&await b(),d[e]&&0!==Object.keys(d[e]).length)for(const i of t)setTimeout(async()=>{a.info(`[RealTime-Calc] 🔄 Starting setTimeout for ${e}.${i}`);try{const{ItemsService:t}=r;a.info(`[RealTime-Calc] 📦 Creating ItemsService for ${e}`);const u=new t(e,{database:l,schema:o||("function"==typeof s?await s():void 0),accountability:c});a.info(`[RealTime-Calc] 📖 Reading item ${i} from ${e}`);const f=await u.readOne(i);a.info(`[RealTime-Calc] ✅ Got item data for ${i}:`,JSON.stringify(f)),a.debug(`[RealTime-Calc] Updated item data for ${i}:`,f);const g=Object.keys(n);a.info(`[RealTime-Calc] 🧮 Calling calculateFields for ${e} with changedFields: ${g.join(", ")}`),a.info(`[RealTime-Calc] 📊 formulaConfigs for ${e}:`,JSON.stringify(d[e]));const{updates:m,hasChanges:h}=R(e,f,g);if(a.info(`[RealTime-Calc] 📝 calculateFields returned: hasChanges=${h}, updates=${JSON.stringify(m)}`),a.debug(`[RealTime-Calc] changedFields: ${g.join(", ")}`),a.debug("[RealTime-Calc] calculatedUpdates:",m),h&&Object.keys(m).length>0){const t={};Object.keys(m).forEach(e=>{_(m[e],f[e])||(t[e]=m[e],a.info(`[RealTime-Calc] Calculated field ${e} changed: ${f[e]} → ${m[e]}`))}),Object.keys(t).length>0?(await u.updateOne(i,t),a.info(`[RealTime-Calc] ✅ Updated ${e}.${i} with calculated fields:`,t)):a.debug(`[RealTime-Calc] Calculated fields unchanged for ${e}.${i}`)}else a.debug(`[RealTime-Calc] No calculated fields to update for ${e}.${i}`)}catch(t){a.error(`[RealTime-Calc] ❌ Error in items.update action for ${e}.${i}:`),a.error(t)}},100);else a.debug(`[RealTime-Calc] No formulas for ${e}, skipping`);else y("quartz_formulas.update")}),t("items.delete",async({collection:e,keys:t})=>{a.info(`[RealTime-Calc] 🗑️ items.delete ACTION for ${e}, keys:`,t),"quartz_formulas"!==e||y("quartz_formulas.delete")}),t("realtime-calc.test-formula",async({formula:e,sampleData:t})=>{const r=c.parser.validate(e,t||{});if(r.valid){const t=c.extractDependencies(e),n=c.isLocal(e);return{valid:!0,result:r.result,fields:t,isLocal:n,message:n?`Formula is valid (local). Result: ${r.result}`:`Formula is valid but requires full engine (uses relations/aggregations). Result: ${r.result}`}}return{valid:!1,error:r.error,message:`Formula error: ${r.error}`}}),t("realtime-calc.reload-formulas",async()=>{try{a.info("[RealTime-Calc] 🔄 Reloading formulas from database (stable)...");const e=await C({attempts:3,settleDelayMs:700,reason:"manual"}),t={collections:Object.keys(d).length,totalFormulas:Object.values(d).reduce((e,t)=>e+Object.keys(t).length,0)};a.info(`[RealTime-Calc] ✅ Reloaded ${t.totalFormulas} formula(s) from ${t.collections} collection(s)`);const r=Object.fromEntries(Object.entries(d).map(([e,t])=>[e,Object.fromEntries(Object.entries(t).map(([e,t])=>[e,t.formula]))]));return a.info(`[RealTime-Calc] 🧾 Formulas content: ${JSON.stringify(r)}`),{success:e,message:`Reloaded ${t.totalFormulas} formula(s) from ${t.collections} collection(s)`,stats:t}}catch(e){return a.error("[RealTime-Calc] ❌ Failed to reload formulas:",e),{success:!1,error:e.message,message:`Failed to reload formulas: ${e.message}`}}}),t("realtime-calc.recalculate-collection",async({collection:e,filter:t=null,batchSize:n=100,dryRun:o=!1},{schema:c,accountability:i})=>{try{if(!e||"string"!=typeof e)throw new Error('Missing or invalid "collection"');if(0===Object.keys(d).length&&await b(),!d[e]||0===Object.keys(d[e]).length)return{success:!0,updated:0,processed:0,total:0,message:`No formulas for collection ${e}`};const{ItemsService:u}=r,f=new u(e,{database:l,schema:c||("function"==typeof s?await s():void 0),accountability:i});let g=0;const m=Math.max(1,Math.min(500,Number(n)||100));let h=0,T=0,p=0;try{const e=await f.readByQuery({filter:t||{},limit:0,meta:"total_count"});e&&e.meta&&"number"==typeof e.meta.total_count&&(p=e.meta.total_count)}catch{}for(;;){const r=await f.readByQuery({filter:t||{},limit:m,offset:g}),n=Array.isArray(r)?r:r?.data||[];if(!n||0===n.length)break;for(const t of n){const{updates:r,hasChanges:n}=R(e,t);if(h++,n&&Object.keys(r).length>0)if(o)T++;else try{await f.updateOne(t.id,r),T++}catch(r){a.error(`[RealTime-Calc] Error updating ${e}.${t.id} during recalc:`,r?.message||r)}}if(g+=n.length,n.length<m)break}return{success:!0,collection:e,processed:h,updated:T,total:p,dryRun:o,message:o?`Dry-run: ${T} item(s) would be updated on ${h} processed.`:`Updated ${T} item(s) on ${h} processed.`}}catch(e){return a.error("[RealTime-Calc] ❌ Failed recalculate-collection:",e?.message||e),{success:!1,error:e?.message||String(e)}}}),t("realtime-calc.get-config",async()=>{const e={};for(const[t,r]of Object.entries(d))e[t]={formulaCount:Object.keys(r).length,fields:Object.keys(r),hasCircularDeps:f[t]?.cycles.length>0,calculationOrder:f[t]?.order||[]};return{collections:Object.keys(d).length,stats:e}}),(async()=>{if(await b()){const e=Object.values(d).reduce((e,t)=>e+Object.keys(t).length,0);a.info("[RealTime-Calc Extension] Loaded successfully"),a.info(`[RealTime-Calc] Monitoring ${Object.keys(d).length} collection(s) with ${e} formula(s)`)}else a.warn("[RealTime-Calc Extension] Started but no formulas loaded (table may not exist yet)")})()};export{p as default};
