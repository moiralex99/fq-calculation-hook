const e={millisecond:1,second:1e3,minute:6e4,hour:36e5,day:864e5,week:6048e5},t=new Set(["day","week","month","quarter","year"]),a=new Set(["month","quarter","year"]);function r(e){return String(e||"").toLowerCase()}function l(e){return new Date(e.getTime())}function n(e){if(null==e||""===e)return null;if(e instanceof Date)return l(e);const t=new Date(e);return Number.isNaN(t.getTime())?null:t}function s(e){if(!e)return null;return`${e.getFullYear()}-${String(e.getMonth()+1).padStart(2,"0")}-${String(e.getDate()).padStart(2,"0")}`}function o(e){return e?e.toISOString():null}function c(e,t){const a=l(e),r=a.getMonth()+t;a.setDate(1),a.setMonth(r);const n=e.getDate(),s=new Date(a.getFullYear(),a.getMonth()+1,0).getDate();return a.setDate(Math.min(n,s)),a}function i(t,a,l){const n=r(a);if(!Number.isFinite(l))return null;if("quarter"===n)return c(t,3*l);if("year"===n)return c(t,12*l);if("month"===n)return c(t,l);const s=e[n];return s?new Date(t.getTime()+l*s):null}function u(e,t){const a=r(t),n=l(e);switch(a){case"day":return n.setHours(0,0,0,0),n;case"week":{const e=(n.getDay()+6)%7;return n.setHours(0,0,0,0),n.setDate(n.getDate()-e),n}case"month":return n.setHours(0,0,0,0),n.setDate(1),n;case"quarter":{n.setHours(0,0,0,0);const e=3*Math.floor(n.getMonth()/3);return n.setMonth(e,1),n}case"year":return n.setHours(0,0,0,0),n.setMonth(0,1),n;default:return n}}function f(e){if(null==e||""===e)return null;const t=Number(e);return Number.isNaN(t)?null:t}function d(e,t,{strict:a=!0}={}){const r=String(t||"").toLowerCase();if(null==e)return null;const l=e=>{if(a)throw new Error(e);return null};switch(r){case"string":case"text":return String(e);case"int":case"integer":case"bigint":{const t=f(e);return null==t?l("Invalid integer cast"):Math.trunc(t)}case"float":case"double":case"decimal":case"numeric":return f(e)??l("Invalid decimal cast");case"bool":case"boolean":{if("boolean"==typeof e)return e;if("number"==typeof e)return 0!==e;const t=String(e).trim().toLowerCase();return!!["true","1","yes","y"].includes(t)||!["false","0","no","n"].includes(t)&&l("Invalid boolean cast")}case"date":{const t=n(e);return t?s(t):l("Invalid date cast")}case"datetime":case"timestamp":{const t=n(e);return t?o(t):l("Invalid datetime cast")}default:return l(`Unsupported cast type: ${t}`)}}class m{constructor(){this.tokenRegex=/(\{\{[a-zA-Z0-9_\.]+\}\}|"(?:[^"\\]|\\.)*"|[0-9]+(?:\.[0-9]+)?|\b(?:IF|CASE_WHEN|COALESCE|ROUND|ABS|CEIL|FLOOR|NULLIF|IS_NULL|IS_BLANK|IN|IN_CI|IN_ANY|BETWEEN|EQ|NE|LT|LTE|GT|GTE|DATE_DIFF|DATEDIFF|DATE_ADD|DATE_TRUNC|EXTRACT|START_OF|END_OF|MAKE_DATE|TODAY|NOW|UPPER|LOWER|LENGTH|LEFT|RIGHT|SUBSTR|SUBSTRING|TRIM|LTRIM|RTRIM|REPLACE|REGEX_MATCH|REGEX_EXTRACT|REGEX_REPLACE|CONCAT|CONCAT_WS|CAST|TRY_CAST|ADD|SUB|MUL|DIV|MOD|NEGATE|POWER|SQRT|SIGN|GREATEST|LEAST|AND|OR|NOT|true|false|null)\b|[+\-*\/%()=<>!,]|<=|>=|<>|!=)/gi}compile(e){if(!e)return()=>null;try{const t=this.dslToJavaScript(e),a=this.createHelpers(),r=Object.entries(a),l=r.map(([e])=>e),n=new Function("data",...l,`\n        return (${t});\n      `);return e=>{const t=r.map(([,e])=>e);return n(e,...t)}}catch(e){throw new Error(`Failed to compile formula: ${e.message}`)}}dslToJavaScript(e){let t=e;t=t.replace(/\{\{([a-zA-Z0-9_]+)\}\}/g,(e,t)=>`(data.${t})`),t=t.replace(/\{\{([a-zA-Z0-9_]+)\.([a-zA-Z0-9_]+)\}\}/g,()=>"null /* cross-collection reference not supported */"),t=t.replace(/\s+AND\s+/gi," && "),t=t.replace(/\s+OR\s+/gi," || "),t=t.replace(/\bNOT\s+/gi,"!"),t=t.replace(/\s*<=\s*/g," __LTE__ "),t=t.replace(/\s*>=\s*/g," __GTE__ "),t=t.replace(/\s*<>\s*/g," __NEQ__ "),t=t.replace(/\s*!=\s*/g," __NEQ__ "),t=t.replace(/\s*<\s*/g," __LT__ "),t=t.replace(/\s*>\s*/g," __GT__ "),t=t.replace(/(?<![=<>!])\s*=\s*(?![=])/g,(e,a)=>{const r=t.substring(0,a),l=(r.match(/"/g)||[]).length,n=(r.match(/'/g)||[]).length;return l%2==1||n%2==1?e:" __EQ__ "}),t=t.replace(/__LTE__/g,"<="),t=t.replace(/__GTE__/g,">="),t=t.replace(/__NEQ__/g,"!=="),t=t.replace(/__LT__/g,"<"),t=t.replace(/__GT__/g,">"),t=t.replace(/__EQ__/g,"==="),t=t.replace(/\band\s*\(/gi,"AND_FUNC("),t=t.replace(/\bor\s*\(/gi,"OR_FUNC("),t=t.replace(/\bnot\s*\(/gi,"NOT_FUNC(");const a=["IF","CASE_WHEN","COALESCE","ROUND","ABS","CEIL","FLOOR","NULLIF","IS_NULL","IS_BLANK","IN","IN_CI","IN_ANY","BETWEEN","EQ","NE","LT","LTE","GT","GTE","DATE_DIFF","DATEDIFF","DATE_ADD","DATE_TRUNC","EXTRACT","START_OF","END_OF","MAKE_DATE","TODAY","NOW","UPPER","LOWER","LENGTH","LEFT","RIGHT","SUBSTR","SUBSTRING","TRIM","LTRIM","RTRIM","REPLACE","REGEX_MATCH","REGEX_EXTRACT","REGEX_REPLACE","CONCAT","CONCAT_WS","CAST","TRY_CAST","ADD","SUB","MUL","DIV","MOD","NEGATE","POWER","SQRT","SIGN","GREATEST","LEAST"];for(const e of a){const a=new RegExp(`\\b${e}\\s*\\(`,"gi");t=t.replace(a,`${e}(`)}return t}createHelpers(){const c={};function m(e){if("boolean"==typeof e)return e;if("number"==typeof e)return 0!==e;if(null==e)return e;const t=String(e).trim().toLowerCase();return!!["true","1","yes","y"].includes(t)||!["false","0","no","n"].includes(t)&&e}function g(e,t){if(null==e&&null==t)return!0;if(null==e||null==t)return!1;const a=function(e,t){const a=f(e),r=f(t);return null!=a&&null!=r?[a,r]:null}(e,t);if(a){const[e,t]=a;return Math.abs(e-t)<1e-7}const r=function(e,t){const a=n(e),r=n(t);return a&&r?[a,r]:null}(e,t);if(r){const[e,t]=r;return e.getTime()===t.getTime()}const l=m(e),s=m(t);return"boolean"==typeof l&&"boolean"==typeof s?l===s:e===t}function h(e){if(null==e)return e;if("number"==typeof e)return e;if("boolean"==typeof e)return e;const t=String(e).trim();if("true"===t||"false"===t)return"true"===t;const a=Number(t);return Number.isNaN(a)?t:a}return c.IF=(e,t,a)=>e?t:a,c.CASE_WHEN=(...e)=>{const t=e.length;for(let a=0;a<t-1;a+=2)if(e[a])return e[a+1];return t%2==1?e[t-1]:null},c.COALESCE=(...e)=>{for(const t of e)if(null!=t&&void 0!==t)return t;return null},c.ROUND=(e,t=2)=>{const a=f(e);if(null==a)return null;const r=10**(t??0);return Math.round(a*r)/r},c.ABS=e=>{const t=f(e);return null==t?null:Math.abs(t)},c.CEIL=e=>{const t=f(e);return null==t?null:Math.ceil(t)},c.FLOOR=e=>{const t=f(e);return null==t?null:Math.floor(t)},c.NULLIF=(e,t)=>e===t?null:e,c.IS_NULL=e=>null==e,c.IS_BLANK=e=>null==e||("string"==typeof e?""===e.trim():!!Array.isArray(e)&&0===e.length),c.IN=(e,...t)=>{const a=Array.isArray(e)?e.map(h):h(e),r=t.flat();for(const e of r){const t=h(e);if(Array.isArray(a)){if(a.some(e=>e===t))return!0}else if(a===t)return!0}return!1},c.IN_CI=(e,...t)=>{const a=e=>null==e?e:String(e).trim().toLowerCase(),r=Array.isArray(e)?e.map(a):[a(e)],l=t.flat().map(a);return r.some(e=>l.includes(e))},c.IN_ANY=(e,...t)=>{const a=Array.isArray(e)?e.map(h):[h(e)];const r=t.flat().map(h);return a.some(e=>r.includes(e))},c.BETWEEN=(e,t,a)=>{if(null==e||null==t||null==a)return!1;const r=n(e),l=n(t),s=n(a);if(r&&l&&s){let e=l.getTime(),t=s.getTime();e>t&&([e,t]=[t,e]);const a=r.getTime();return a>=e&&a<=t}const o=f(e),c=f(t),i=f(a);if(null!=o&&null!=c&&null!=i){let e=c,t=i;return e>t&&([e,t]=[t,e]),o>=e&&o<=t}const u=String(e);let d=String(t),m=String(a);return d>m&&([d,m]=[m,d]),u>=d&&u<=m},c.EQ=(e,t)=>g(e,t),c.NE=(e,t)=>!g(e,t),c.LT=(e,t)=>{const a=f(e),r=f(t);if(null!=a&&null!=r)return a<r;const l=n(e),s=n(t);return l&&s?l.getTime()<s.getTime():e<t},c.LTE=(e,t)=>{const a=f(e),r=f(t);if(null!=a&&null!=r)return a<=r;const l=n(e),s=n(t);return l&&s?l.getTime()<=s.getTime():e<=t},c.GT=(e,t)=>{const a=f(e),r=f(t);if(null!=a&&null!=r)return a>r;const l=n(e),s=n(t);return l&&s?l.getTime()>s.getTime():e>t},c.GTE=(e,t)=>{const a=f(e),r=f(t);if(null!=a&&null!=r)return a>=r;const l=n(e),s=n(t);return l&&s?l.getTime()>=s.getTime():e>=t},c.DATE_DIFF=(t,l,s)=>function(t,l,s){const o=r(t),c=n(l),i=n(s);if(!c||!i)return null;const u=i.getTime()-c.getTime();if(a.has(o)){const e=12*(i.getFullYear()-c.getFullYear())+(i.getMonth()-c.getMonth()),t=i.getDate()-c.getDate();let a=e;if(u>=0&&t<0?a-=1:u<0&&t>0&&(a+=1),"month"===o)return a;if("quarter"===o)return Math.trunc(a/3);if("year"===o)return Math.trunc(a/12)}const f=e[o];return f?Math.trunc(u/f):null}(t,l,s),c.DATEDIFF=(e,t,a)=>c.DATE_DIFF(a,t,e),c.DATE_ADD=(e,a,l)=>{const c=n(l),u=f(a);if(!c||null==u)return null;const d=i(c,e,u);return d?t.has(r(e))?s(d):o(d):null},c.DATE_TRUNC=(e,a)=>{const l=n(a);if(!l)return null;const c=u(l,e);return t.has(r(e))?s(c):o(c)},c.START_OF=(e,t)=>c.DATE_TRUNC(e,t),c.END_OF=(e,a)=>{const c=n(a);if(!c)return null;const f=function(e,t){const a=r(t);if("day"===a){const t=l(e);return t.setHours(23,59,59,999),t}const n=u(e,a),s=i(n,a,1);return s?(s.setMilliseconds(s.getMilliseconds()-1),s):n}(c,e);return t.has(r(e))?s(f):o(f)},c.MAKE_DATE=(e,t,a)=>{const r=f(e),l=f(t),n=f(a);if(null==r||null==l||null==n)return null;const o=new Date(Date.UTC(r,l-1,n));return Number.isNaN(o.getTime())?null:s(o)},c.TODAY=()=>s(new Date),c.NOW=()=>o(new Date),c.EXTRACT=(e,t)=>{const a=n(t);if(!a)return null;switch(r(e)){case"year":return a.getFullYear();case"month":return a.getMonth()+1;case"day":case"day_of_month":return a.getDate();case"hour":return a.getHours();case"minute":return a.getMinutes();case"second":return a.getSeconds();case"quarter":return Math.floor(a.getMonth()/3)+1;case"week":{const e=new Date(Date.UTC(a.getFullYear(),a.getMonth(),a.getDate())),t=e.getUTCDay()||7;e.setUTCDate(e.getUTCDate()+4-t);const r=new Date(Date.UTC(e.getUTCFullYear(),0,1));return Math.ceil(((e-r)/864e5+1)/7)}case"dow":case"day_of_week":return(a.getDay()+6)%7+1;default:return null}},c.UPPER=e=>null!=e?String(e).toUpperCase():"",c.LOWER=e=>null!=e?String(e).toLowerCase():"",c.LENGTH=e=>null!=e?String(e).length:0,c.LEFT=(e,t)=>{const a=null!=e?String(e):"",r=f(t)??0;return a.slice(0,Math.max(0,r))},c.RIGHT=(e,t)=>{const a=null!=e?String(e):"",r=f(t)??0;return 0===r?"":a.slice(-Math.max(0,r))},c.SUBSTR=(e,t,a)=>{const r=null!=e?String(e):"",l=f(t)??0;if(null==a)return r.substring(l);const n=f(a)??0;return r.substring(l,l+n)},c.SUBSTRING=c.SUBSTR,c.TRIM=e=>null!=e?String(e).trim():"",c.LTRIM=e=>null!=e?String(e).trimStart():"",c.RTRIM=e=>null!=e?String(e).trimEnd():"",c.REPLACE=(e,t,a)=>{if(null==e)return"";const r=String(e),l=null!=t?String(t):"",n=null!=a?String(a):"";return""===l?r:r.split(l).join(n)},c.REGEX_MATCH=(e,t)=>{if(null==e||null==t)return!1;return new RegExp(t).test(String(e))},c.REGEX_EXTRACT=(e,t,a=1)=>{if(null==e||null==t)return null;const r=new RegExp(t).exec(String(e));if(!r)return null;const l=null==a?1:Number(a);return r[Number.isNaN(l)?1:l]??null},c.REGEX_REPLACE=(e,t,a="")=>{if(null==e||null==t)return null;const r=new RegExp(t,"g");return String(e).replace(r,a)},c.CONCAT=(...e)=>e.filter(e=>null!=e&&void 0!==e).map(e=>String(e)).join(""),c.CONCAT_WS=(e,...t)=>{const a=null!=e?String(e):"";return t.filter(e=>null!=e&&void 0!==e).map(e=>String(e)).join(a)},c.CAST=(e,t)=>d(e,t,{strict:!0}),c.TRY_CAST=(e,t)=>d(e,t,{strict:!1}),c.ADD=(...e)=>{if(!e.length)return 0;let t=0;for(const a of e){t+=f(a)??0}return t},c.SUB=(...e)=>{if(!e.length)return null;const t=f(e[0]);if(null==t)return null;let a=t;for(let t=1;t<e.length;t++){a-=f(e[t])??0}return a},c.MUL=(...e)=>{if(!e.length)return null;let t=1;for(const a of e){const e=f(a);if(null==e)return null;t*=e}return t},c.DIV=(e,t)=>{const a=f(e),r=f(t);return null==a||null==r||0===r?null:a/r},c.MOD=(e,t)=>{const a=f(e),r=f(t);return null==a||null==r||0===r?null:a%r},c.NEGATE=e=>{const t=f(e);return null==t?null:-t},c.POWER=(e,t)=>{const a=f(e),r=f(t);return null==a||null==r?null:Math.pow(a,r)},c.SQRT=e=>{const t=f(e);return null==t||t<0?null:Math.sqrt(t)},c.SIGN=e=>{const t=f(e);return null==t?null:t>0?1:t<0?-1:0},c.GREATEST=(...e)=>{const t=e.map(f).filter(e=>null!=e);return t.length?Math.max(...t):null},c.LEAST=(...e)=>{const t=e.map(f).filter(e=>null!=e);return t.length?Math.min(...t):null},c.AND_FUNC=(...e)=>e.every(e=>Boolean(e)),c.OR_FUNC=(...e)=>e.some(e=>Boolean(e)),c.NOT_FUNC=e=>!Boolean(e),c}extractFields(e){if(!e)return[];const t=[],a=/\{\{([a-zA-Z0-9_]+(?:\.[a-zA-Z0-9_]+)?)\}\}/g;let r;for(;null!==(r=a.exec(e));)t.push(r[1]);return[...new Set(t)]}extractLocalDependencies(e){return this.extractFields(e).filter(e=>!e.includes("."))}isLocalFormula(e){if(!e)return!0;const t=[/\{\{[a-zA-Z0-9_]+\.[a-zA-Z0-9_]+\}\}/,/\bLOOKUP\s*\(/i,/\bPARENT\s*\(/i,/\bCHILDREN\s*\(/i,/\bRELATED\s*\(/i,/\bSUM\s*\(/i,/\bAVG\s*\(/i,/\bCOUNT\s*\(/i,/\bMIN\s*\(/i,/\bMAX\s*\(/i,/\bCOUNT_DISTINCT\s*\(/i];for(const a of t)if(a.test(e))return!1;return!0}validate(e,t={}){try{const a=this.compile(e);return{valid:!0,result:a(t)}}catch(e){return{valid:!1,error:e.message}}}}class g{constructor(e){this.parser=new m,this.logger=e,this.compiledCache=new Map}evaluate(e,t){try{let a=this.compiledCache.get(e);a||(a=this.parser.compile(e),this.compiledCache.set(e,a));const r=a(t);return this.logger?.debug(`Evaluated: ${e} = ${r}`),r}catch(t){throw this.logger?.error(`Error evaluating formula "${e}":`,t.message),t}}clearCache(){this.compiledCache.clear()}getCacheSize(){return this.compiledCache.size}extractDependencies(e){return this.parser.extractLocalDependencies(e)}isLocal(e){return this.parser.isLocalFormula(e)}isLocalFormula(e){return this.isLocal(e)}}class h{constructor(e,t){this.database=e,this.logger=t,this.parser=new m,this.cachedFormulas=null,this.lastLoadTime=null,this.CACHE_TTL=6e4}async loadFormulas(){try{if(this.cachedFormulas&&this.lastLoadTime&&Date.now()-this.lastLoadTime<this.CACHE_TTL)return this.cachedFormulas;const e=await this.database("quartz_formulas").select("*").where("status","published").orderBy("collection_cible","asc").orderBy("sort","asc").orderBy("champ_cible","asc"),t={};for(const a of e){const e=a.collection_cible;if(!e){this.logger?.warn("[FormulaLoader] Missing collection_cible on row id="+a.id);continue}t[e]||(t[e]={});const r=a.champ_cible,l=a.formula;if(!r||!l){this.logger?.warn(`[FormulaLoader] Missing champ_cible or formula for ${e} (id=${a.id})`);continue}const n=this.parser.extractLocalDependencies(l);t[e][r]={formula:l,dependencies:n,isLocal:this.parser.isLocalFormula(l),metadata:{id:a.id,description:a.description,sort:a.sort,updated_at:a.date_updated}}}return this.cachedFormulas=t,this.lastLoadTime=Date.now(),this.logger?.info(`[FormulaLoader] Loaded ${e.length} formula(s) from ${Object.keys(t).length} collection(s)`),t}catch(e){if(this.logger?.error("[FormulaLoader] Error loading formulas:",e.message),e.message.includes("does not exist"))return this.logger?.warn("[FormulaLoader] Table quartz_formulas not found. Using empty config."),{};throw e}}filterLocalFormulas(e){const t={};let a=0;for(const[r,l]of Object.entries(e)){t[r]={};for(const[e,n]of Object.entries(l))n.isLocal?t[r][e]=n:(this.logger?.info(`[FormulaLoader] Skipping non-local formula: ${r}.${e}`),a++);0===Object.keys(t[r]).length&&delete t[r]}return a>0&&this.logger?.info(`[FormulaLoader] Filtered out ${a} non-local formula(s) (require full engine)`),t}async reloadFormulas(){return this.cachedFormulas=null,this.lastLoadTime=null,await this.loadFormulas()}async loadLocalFormulas(){const e=await this.loadFormulas();return this.filterLocalFormulas(e)}}class p{constructor(e){this.logger=e}buildGraph(e){const t={},a=new Set;for(const[r,l]of Object.entries(e))a.add(r),t[r]={formula:l.formula,dependencies:l.dependencies||[],dependents:[]};for(const[e,a]of Object.entries(t))for(const r of a.dependencies)t[r]&&t[r].dependents.push(e);return t}topologicalSort(e){const t=new Set,a=new Set,r=[],l=[],n=(s,o=[])=>{if(a.has(s)){const e=o.indexOf(s),t=o.slice(e).concat(s);return l.push(t),!1}if(t.has(s))return!0;a.add(s),o.push(s);const c=e[s]?.dependencies||[];for(const t of c)if(e[t]&&!n(t,[...o]))return!1;return a.delete(s),t.add(s),r.push(s),!0};for(const a of Object.keys(e))t.has(a)||n(a);return{order:r,cycles:l}}analyze(e){const t=this.buildGraph(e),{order:a,cycles:r}=this.topologicalSort(t),l=this.calculateLevels(t,a);return r.length>0&&(this.logger?.warn(`[DependencyGraph] Detected ${r.length} circular dependency(ies):`),r.forEach(e=>{this.logger?.warn(`  -> ${e.join(" → ")}`)})),this.logger?.debug(`[DependencyGraph] Calculation order: ${a.join(" → ")}`),{order:a,graph:t,cycles:r,levels:l}}calculateLevels(e,t){const a={};for(const r of t){const t=e[r]?.dependencies||[];let l=-1;for(const e of t)void 0!==a[e]&&(l=Math.max(l,a[e]));a[r]=l+1}return a}getAffectedFields(e,t){const a=new Set,r=[...t],l=new Set;for(;r.length>0;){const t=r.shift();if(!l.has(t)){l.add(t);for(const[l,n]of Object.entries(e))n.dependencies.includes(t)&&(a.has(l)||(a.add(l),r.push(l)))}}return Array.from(a)}optimizeCalculationOrder(e,t,a){const r=this.getAffectedFields(e,a),l=new Set([...a,...r]),n=t.filter(e=>l.has(e));return this.logger?.debug(`[DependencyGraph] Changed: ${a.join(", ")}`),this.logger?.debug(`[DependencyGraph] Recalculate: ${n.join(" → ")}`),n}collectDependencyClosure(e,t){const a=new Set;if(!Array.isArray(t)||0===t.length)return a;const r=t=>{if(t&&!a.has(t))if(e&&e[t]){a.add(t);const l=e[t]?.dependencies||[];for(const t of l)e[t]&&r(t)}else a.add(t)};for(const e of t)r(e);return a}visualize(e){let t="\n=== Dependency Graph ===\n";for(const[a,r]of Object.entries(e))t+=`\n${a}:\n`,r.dependencies.length>0&&(t+=`  depends on: ${r.dependencies.join(", ")}\n`),r.dependents.length>0&&(t+=`  triggers: ${r.dependents.join(", ")}\n`),t+=`  formula: ${r.formula}\n`;return t}}async function T({services:e,database:t,logger:a,getSchema:r,formulaConfigs:l,dependencyGraphs:n,calculateFields:s,dependencyGraph:o}){return async function({collection:c,fields:i=null,filter:u=null,batchSize:f=100,dryRun:d=!1},{schema:m,accountability:g}){if(a.info("[RealTime-Calc] recalculate-collection → start"),a.info(`[RealTime-Calc] Params: collection=${c}, fields=${JSON.stringify(i)}, batchSize=${f}, dryRun=${d}`),!c||"string"!=typeof c)throw new Error('Missing or invalid "collection"');if(a.info(`[RealTime-Calc] formulaConfigs has ${Object.keys(l).length} collection(s)`),!l[c]||0===Object.keys(l[c]).length)return a.warn(`[RealTime-Calc] No local formulas for ${c}`),{success:!0,updated:0,processed:0,total:0,message:`No formulas for collection ${c}`};a.info(`[RealTime-Calc] ${c} has ${Object.keys(l[c]).length} local formula(s)`);const h=Array.isArray(i)?i.map(e=>"string"==typeof e?e:String(e)).filter(Boolean):"string"==typeof i?[i]:[],p=Object.keys(l[c]);let T=null;if(h.length>0){const e=n[c];if(T=o.collectDependencyClosure(e?.graph,h),!T||0===T.size)return{success:!1,error:"no_matching_fields",message:`None of the requested fields (${h.join(", ")}) match local formulas for collection ${c}.`};const t=h.filter(e=>!p.includes(e));t.length>0&&a.warn(`[RealTime-Calc] Some requested fields are not local formulas for ${c}: ${t.join(", ")}`)}const{ItemsService:y}=e,C=new y(c,{database:t,schema:m||("function"==typeof r?await r():void 0),accountability:g});let R=0;const b=Math.max(1,Math.min(500,Number(f)||100));let E=0,S=0,O=0;try{const e=await C.readByQuery({filter:u||{},limit:0,meta:"total_count"});e&&e.meta&&"number"==typeof e.meta.total_count&&(O=e.meta.total_count)}catch{}for(a.info(`[RealTime-Calc] Starting batch processing: total=${O}, limit=${b}`);;){const e=await C.readByQuery({filter:u||{},limit:b,offset:R}),t=Array.isArray(e)?e:e?.data||[];if(!t||0===t.length)break;a.info(`[RealTime-Calc] Processing batch: offset=${R}, size=${t.length}`);for(const e of t){const{updates:t,hasChanges:r}=s(c,e,null,{targetFields:h});if(E++,r&&Object.keys(t).length>0)if(d)S++;else try{await C.updateOne(e.id,t),S++}catch(t){a.error(`[RealTime-Calc] Error updating ${c}.${e.id} during recalc:`,t?.message||t)}}if(R+=t.length,t.length<b)break}const $={success:!0,collection:c,processed:E,updated:S,total:O,dryRun:d,fields:h.length>0?Array.from(T||new Set(h)):p,message:d?`Dry-run: ${S} item(s) would be updated on ${E} processed.`:`Updated ${S} item(s) on ${E} processed.`};return a.info(`[RealTime-Calc] Recalculate → success: ${JSON.stringify($)}`),$}}const y=[{name:"realtime-calc-hook",config:({filter:e,action:t},{services:a,exceptions:r,logger:l,database:n,getSchema:s,env:o})=>{const c=new g(l),i=new h(n,l),u=new p(l),f=new Set;let d={},m={},y=null,C=null,R=null;function b(e){if(null===e||"object"!=typeof e)return JSON.stringify(e);if(Array.isArray(e))return"["+e.map(b).join(",")+"]";return"{"+Object.keys(e).sort().map(t=>`${JSON.stringify(t)}:${b(e[t])}`).join(",")+"}"}function E(e){try{return b(e)}catch(e){return l.warn("[RealTime-Calc] Could not compute config signature:",e?.message||e),""+Date.now()}}async function S({attempts:e=3,settleDelayMs:t=700,reason:a="unknown"}={}){let r=null,n=null;for(let s=1;s<=e;s++){const o=await i.reloadFormulas(),c=i.filterLocalFormulas(o),u=E(c);if(l.debug(`[RealTime-Calc] Reload attempt ${s}/${e} (reason: ${a}) signature: ${u.substring(0,32)}…`),r&&u===r){l.info(`[RealTime-Calc] 🔒 Reload stabilized on attempt ${s} (reason: ${a})`),n=c;break}r=u,n=c,s<e&&await new Promise(e=>setTimeout(e,t))}return await async function(e){d=e||{},m={};for(const[e,t]of Object.entries(d)){const a=u.analyze(t);m[e]=a,a.cycles.length>0&&l.warn(`[RealTime-Calc] Collection ${e} has circular dependencies!`),l.debug(`[RealTime-Calc] ${e}: ${a.order.length} local formula(s) loaded`)}return!0}(n)}function O(e="unknown"){try{y&&clearTimeout(y),y=setTimeout(async()=>{l.info(`[RealTime-Calc] 🔁 Auto-reloading formulas (reason: ${e})...`);if(await S({attempts:3,settleDelayMs:700,reason:e})){const e=Object.values(d).reduce((e,t)=>e+Object.keys(t).length,0),t=Object.fromEntries(Object.entries(d).map(([e,t])=>[e,Object.keys(t).length])),a=Object.fromEntries(Object.entries(d).map(([e,t])=>[e,Object.keys(t)])),r=Object.fromEntries(Object.entries(d).map(([e,t])=>[e,Object.fromEntries(Object.entries(t).map(([e,t])=>[e,t.formula]))]));l.info(`[RealTime-Calc] ✅ Auto-reload complete: ${e} formula(s) active across ${Object.keys(d).length} collection(s)`),l.info(`[RealTime-Calc] 📦 Reload collections: ${JSON.stringify(t)}`),l.debug(`[RealTime-Calc] 📄 Fields per collection: ${JSON.stringify(a)}`),l.info(`[RealTime-Calc] 🧾 Formulas content: ${JSON.stringify(r)}`)}else l.warn("[RealTime-Calc] ⚠️ Auto-reload failed");y=null},5e3)}catch(e){l.error("[RealTime-Calc] Error scheduling formulas reload:",e?.message||e)}}async function $(){try{d=await i.loadLocalFormulas();for(const[e,t]of Object.entries(d)){const a=u.analyze(t);m[e]=a,a.cycles.length>0&&l.warn(`[RealTime-Calc] Collection ${e} has circular dependencies!`),l.debug(`[RealTime-Calc] ${e}: ${a.order.length} local formula(s) loaded`)}return!0}catch(e){return l.error("[RealTime-Calc] Error loading formulas:",e.message),!1}}function _(e,t,a=null,r={}){const{targetFields:n=null}=r,s=d[e];if(!s||0===Object.keys(s).length)return{updates:{},hasChanges:!1};const o=m[e],i=o?.graph,f={};let g=!1;const h=Array.isArray(n)?n.map(e=>"string"==typeof e?e:String(e)).filter(Boolean):"string"==typeof n?[n]:[];let p=null;if(h.length>0){const e=u.collectDependencyClosure(i,h);p=e.size>0?e:new Set(h)}let T=o?.order||Object.keys(s);if(a&&a.length>0&&i&&(T=u.optimizeCalculationOrder(i,o?.order||[],a),0===T.length))return l.debug(`[RealTime-Calc] No fields affected by changes in ${e}`),{updates:{},hasChanges:!1};if(p&&(T=T.filter(e=>p.has(e)),0===T.length))return l.debug(`[RealTime-Calc] No formulas match requested fields in ${e}: ${h.join(", ")}`),{updates:{},hasChanges:!1};for(const a of T){const r=s[a];try{const n={...t,...f},s=c.evaluate(r.formula,n),o=t[a];w(o,s)?l.debug(`[RealTime-Calc] calc ${e}.${a}: unchanged (${o})`):(f[a]=s,g=!0,l.debug(`[RealTime-Calc] calc ${e}.${a}: ${o} → ${s}`))}catch(t){l.error(`[RealTime-Calc] Error calculating ${e}.${a}:`,t.message)}}return{updates:f,hasChanges:g}}function w(e,t){if(e===t)return!0;if(null==e&&null==t)return!0;if(null==e||null==t)return!1;const a=e=>"boolean"==typeof e?e:1===e||"1"===e||"true"===e||0!==e&&"0"!==e&&"false"!==e&&e,r=a(e),l=a(t);if(r===l)return!0;if("number"==typeof r&&"number"==typeof l){if(isNaN(r)&&isNaN(l))return!0;const e=1e-7;return Math.abs(r-l)<e}return("string"==typeof r||"string"==typeof l)&&String(r)===String(l)}t("items.create",async({collection:e,key:t,payload:r},{schema:o,accountability:c})=>{l.info(`[RealTime-Calc] ✨ items.create ACTION for ${e}.${t}`),"quartz_formulas"!==e?(0===Object.keys(d).length&&await $(),d[e]&&0!==Object.keys(d[e]).length?setTimeout(async()=>{try{const{ItemsService:r}=a,i=new r(e,{database:n,schema:o||("function"==typeof s?await s():void 0),accountability:c}),u=await i.readOne(t);l.debug("[RealTime-Calc] Created item data:",u);const{updates:f,hasChanges:d}=_(e,u);d&&Object.keys(f).length>0?(await i.updateOne(t,f),l.info(`[RealTime-Calc] ✅ Updated ${e}.${t} with calculated fields:`,f)):l.debug(`[RealTime-Calc] No calculated fields to update for ${e}.${t}`)}catch(a){l.error(`[RealTime-Calc] ❌ Error in items.create action for ${e}.${t}:`,a.message)}},100):l.debug(`[RealTime-Calc] No formulas for ${e}, skipping`)):O("quartz_formulas.create")}),t("items.update",async({collection:e,keys:t,payload:r},{schema:o,accountability:c})=>{if(l.info(`[RealTime-Calc] ✏️ items.update ACTION for ${e}, keys:`,t),l.debug("[RealTime-Calc] Payload:",r),"quartz_formulas"!==e)if(0===Object.keys(d).length&&await $(),d[e]&&0!==Object.keys(d[e]).length)for(const i of t){const t=`${e}:${i}`;f.has(t)?(l.debug(`[RealTime-Calc] ⏭️ Skipping self-triggered update for ${t}`),f.delete(t)):setTimeout(async()=>{l.info(`[RealTime-Calc] 🔄 Starting setTimeout for ${e}.${i}`);try{const{ItemsService:u}=a;l.info(`[RealTime-Calc] 📦 Creating ItemsService for ${e}`);const m=new u(e,{database:n,schema:o||("function"==typeof s?await s():void 0),accountability:c});l.info(`[RealTime-Calc] 📖 Reading item ${i} from ${e}`);const g=await m.readOne(i);l.info(`[RealTime-Calc] ✅ Got item data for ${i}:`,JSON.stringify(g)),l.debug(`[RealTime-Calc] Updated item data for ${i}:`,g);const h=Object.keys(r);l.info(`[RealTime-Calc] 🧮 Calling calculateFields for ${e} with changedFields: ${h.join(", ")}`),l.info(`[RealTime-Calc] 📊 formulaConfigs for ${e}:`,JSON.stringify(d[e]));const{updates:p,hasChanges:T}=_(e,g,h);if(l.info(`[RealTime-Calc] 📝 calculateFields returned: hasChanges=${T}, updates=${JSON.stringify(p)}`),l.debug(`[RealTime-Calc] changedFields: ${h.join(", ")}`),l.debug("[RealTime-Calc] calculatedUpdates:",p),T&&Object.keys(p).length>0){const a={};Object.keys(p).forEach(e=>{w(p[e],g[e])||(a[e]=p[e],l.info(`[RealTime-Calc] Calculated field ${e} changed: ${g[e]} → ${p[e]}`))}),Object.keys(a).length>0?(f.add(t),await m.updateOne(i,a),l.info(`[RealTime-Calc] ✅ Updated ${e}.${i} with calculated fields:`,a)):l.debug(`[RealTime-Calc] Calculated fields unchanged for ${e}.${i}`)}else l.debug(`[RealTime-Calc] No calculated fields to update for ${e}.${i}`)}catch(t){l.error(`[RealTime-Calc] ❌ Error in items.update action for ${e}.${i}:`),l.error(t)}},100)}else l.debug(`[RealTime-Calc] No formulas for ${e}, skipping`);else O("quartz_formulas.update")}),t("items.delete",async({collection:e,keys:t})=>{l.info(`[RealTime-Calc] 🗑️ items.delete ACTION for ${e}, keys:`,t),"quartz_formulas"!==e||O("quartz_formulas.delete")}),t("realtime-calc.test-formula",async({formula:e,sampleData:t})=>{const a=c.parser.validate(e,t||{});if(a.valid){const t=c.extractDependencies(e),r=c.isLocal(e);return{valid:!0,result:a.result,fields:t,isLocal:r,message:r?`Formula is valid (local). Result: ${a.result}`:`Formula is valid but requires full engine (uses relations/aggregations). Result: ${a.result}`}}return{valid:!1,error:a.error,message:`Formula error: ${a.error}`}}),t("realtime-calc.reload-formulas",async()=>{try{l.info("[RealTime-Calc] 🔄 Reloading formulas from database (stable)...");const e=await S({attempts:3,settleDelayMs:700,reason:"manual"}),t={collections:Object.keys(d).length,totalFormulas:Object.values(d).reduce((e,t)=>e+Object.keys(t).length,0)};l.info(`[RealTime-Calc] ✅ Reloaded ${t.totalFormulas} formula(s) from ${t.collections} collection(s)`);const a=Object.fromEntries(Object.entries(d).map(([e,t])=>[e,Object.fromEntries(Object.entries(t).map(([e,t])=>[e,t.formula]))]));return l.info(`[RealTime-Calc] 🧾 Formulas content: ${JSON.stringify(a)}`),{success:e,message:`Reloaded ${t.totalFormulas} formula(s) from ${t.collections} collection(s)`,stats:t}}catch(e){return l.error("[RealTime-Calc] ❌ Failed to reload formulas:",e),{success:!1,error:e.message,message:`Failed to reload formulas: ${e.message}`}}}),t("realtime-calc.recalculate-collection",async(e,t)=>{try{if(!R)throw new Error("Handler not initialized yet");return await R(e,t||{})}catch(e){return l.error("[RealTime-Calc] ❌ Failed recalculate-collection (action):",e?.message||e),{success:!1,error:e?.message||String(e)}}}),e("realtime-calc.recalculate-collection",async(e,t)=>{l.info("[RealTime-Calc] Filter invoked: realtime-calc.recalculate-collection");try{if(!R)throw new Error("Handler not initialized yet");return await R(e||{},t||{})}catch(e){return l.error("[RealTime-Calc] ❌ Failed recalculate-collection (filter):",e?.message||e),{success:!1,error:e?.message||String(e)}}}),l.info("[RealTime-Calc] Filter attached: realtime-calc.recalculate-collection"),t("realtime-calc.get-config",async()=>{C&&await C;const e={};for(const[t,a]of Object.entries(d))e[t]={formulaCount:Object.keys(a).length,fields:Object.keys(a),hasCircularDeps:m[t]?.cycles.length>0,calculationOrder:m[t]?.order||[]};return{collections:Object.keys(d).length,stats:e}}),t("realtime-calc.clear-cache",async()=>{try{return l.info("[RealTime-Calc] 🗑️ Clearing formula cache..."),c.clearCache(),i&&"function"==typeof i.clearCache&&i.clearCache(),l.info("[RealTime-Calc] ✅ Formula cache cleared successfully"),{success:!0,message:"Formula cache cleared"}}catch(e){return l.error("[RealTime-Calc] ❌ Failed to clear cache:",e),{success:!1,error:e.message,message:`Failed to clear cache: ${e.message}`}}}),C=(async()=>{const e=await $();if(R=await T({services:a,database:n,logger:l,getSchema:s,formulaConfigs:d,dependencyGraphs:m,calculateFields:_,dependencyGraph:u}),e){const e=Object.values(d).reduce((e,t)=>e+Object.keys(t).length,0);l.info("[RealTime-Calc Extension] Loaded successfully"),l.info(`[RealTime-Calc] Monitoring ${Object.keys(d).length} collection(s) with ${e} formula(s)`)}else l.warn("[RealTime-Calc Extension] Started but no formulas loaded (table may not exist yet)")})()}}],C=[{name:"realtime-calc",config:(e,{services:t,database:a,logger:r,emitter:l,getSchema:n})=>{e.post("/reload",async(e,t)=>{try{r.info("[RealTime-Calc Endpoint] Triggering formula reload...");const e=await l.emitAction("realtime-calc.reload-formulas",{});t.json({success:!0,...e,timestamp:(new Date).toISOString()})}catch(e){r.error("[RealTime-Calc Endpoint] Error reloading:",e),t.status(500).json({success:!1,error:e.message,message:`Failed to reload: ${e.message}`})}}),e.get("/status",async(e,t)=>{try{const e=await a("quartz_formulas").where({status:"published"}).select("collection_cible","champ_cible","formula"),r=[...new Set(e.map(e=>e.collection_cible))];t.json({success:!0,totalFormulas:e.length,collections:r.length,collectionNames:r,formulas:e,message:`Found ${e.length} published formula(s) across ${r.length} collection(s)`,timestamp:(new Date).toISOString()})}catch(e){r.error("[RealTime-Calc Endpoint] Error:",e),t.status(500).json({success:!1,error:e.message})}}),e.post("/utils/realtime-calc.reload-formulas",async(e,t)=>{try{const e=await l.emitAction("realtime-calc.reload-formulas",{});t.json(e)}catch(e){r.error("[RealTime-Calc Endpoint] utils.reload-formulas error:",e),t.status(500).json({success:!1,error:e.message})}}),e.post("/utils/realtime-calc.get-config",async(e,t)=>{try{const e=await l.emitAction("realtime-calc.get-config",{});t.json(e)}catch(e){r.error("[RealTime-Calc Endpoint] utils.get-config error:",e),t.status(500).json({success:!1,error:e.message})}}),e.post("/utils/realtime-calc.recalculate-collection",async(e,l)=>{try{r.info("[RealTime-Calc Endpoint] Requête recalculate-collection reçue");const{collection:s,fields:o=null,filter:c=null,batchSize:i=100,dryRun:u=!1}=e.body||{};r.info(`[RealTime-Calc Endpoint] Paramètres: collection=${s}, fields=${JSON.stringify(o)}, batchSize=${i}, dryRun=${u}`);const f=new h(a,r),d=new p(r),m=new g(r);r.info("[RealTime-Calc Endpoint] Loading formulas...");const y=await f.loadLocalFormulas(),C={};for(const[w,A]of Object.entries(y)){const N=d.analyze(A);C[w]=N}const R=Object.values(y).reduce((e,t)=>e+Object.keys(t).length,0);function b(e,t,a=null,l={}){const n=y[e];if(!n||0===Object.keys(n).length)return{updates:{},hasChanges:!1};const s=C[e];let o=s?.order||Object.keys(n);const c={};let i=!1;const{targetFields:u=null}=l,f=Array.isArray(u)?u.map(e=>"string"==typeof e?e:String(e)).filter(Boolean):"string"==typeof u?[u]:[];let g=null;f.length>0&&(g=d.collectDependencyClosure(s?.graph,f)),a&&a.length>0&&s?.graph&&(o=d.optimizeCalculationOrder(s.graph,s.order||[],a)),g&&(o=o.filter(e=>g.has(e)));for(const a of o){const l=n[a];try{const e={...t,...c},r=m.evaluate(l.formula,e);r!==t[a]&&(c[a]=r,i=!0)}catch(t){r.error(`[RealTime-Calc Endpoint] Error calculating ${e}.${a}:`,t.message)}}return{updates:c,hasChanges:i}}r.info(`[RealTime-Calc Endpoint] Loaded ${R} formula(s) for ${Object.keys(y).length} collection(s)`),r.info("[RealTime-Calc Endpoint] Creating recalculation handler...");const E=await T({services:t,database:a,logger:r,getSchema:n,formulaConfigs:y,dependencyGraphs:C,calculateFields:b,dependencyGraph:d}),S="function"==typeof n?await n():void 0,O={collection:s,fields:o,filter:c,batchSize:i,dryRun:u},$={schema:S,accountability:e.accountability};r.info("[RealTime-Calc Endpoint] Executing handler...");const _=await E(O,$);r.info(`[RealTime-Calc Endpoint] ✅ Result: ${JSON.stringify(_)}`),l.json(_)}catch(D){r.error("[RealTime-Calc Endpoint] ❌ utils.recalculate-collection error:",D),l.status(500).json({success:!1,error:D.message})}}),e.post("/clear-cache",async(e,t)=>{try{r.info("[RealTime-Calc Endpoint] Clearing formula cache...");await l.emitAction("realtime-calc.clear-cache",{});t.json({success:!0,message:"Formula cache cleared",timestamp:(new Date).toISOString()})}catch(e){r.error("[RealTime-Calc Endpoint] Error clearing cache:",e),t.status(500).json({success:!1,error:e.message})}}),e.post("/test-formula",async(e,t)=>{try{const{formula:a,sampleData:l={}}=e.body;if(!a)return t.status(400).json({success:!1,error:"Formula is required"});r.info(`[RealTime-Calc Endpoint] Testing formula: ${a}`);const n=new g(r);try{const e=n.evaluate(a,l),r=n.extractFields(a),s=!["LOOKUP","PARENT","CHILDREN","RELATED","SUM","AVG","COUNT","MIN","MAX","COUNT_DISTINCT"].some(e=>new RegExp(`\\b${e}\\s*\\(`,"i").test(a));t.json({valid:!0,result:e,fields:r,isLocal:s,message:s?`Formula is valid (local). Result: ${e}`:`Formula is valid but uses relational operations. Result: ${e}`})}catch(e){t.json({valid:!1,error:e.message,message:`Formula error: ${e.message}`})}}catch(e){r.error("[RealTime-Calc Endpoint] Error in test-formula:",e),t.status(500).json({success:!1,error:e.message})}}),e.post("/calculate",async(e,t)=>{try{const{collection:l,data:n,fields:s=null}=e.body;if(!l||!n)return t.status(400).json({success:!1,error:"Collection and data are required"});r.info(`[RealTime-Calc Endpoint] Calculating fields for collection: ${l}`);const o=new h(a,r),c=new p(r),i=new g(r),u=(await o.loadLocalFormulas())[l];if(!u||0===Object.keys(u).length)return t.json({success:!0,updates:{},message:`No formulas for collection ${l}`});const f=c.analyze(u);let d=f?.order||Object.keys(u);if(Array.isArray(s)&&s.length>0){const e=c.collectDependencyClosure(f?.graph,s);d=d.filter(t=>e.has(t))}const m={},T={...n};for(const e of d){const t=u[e];try{const a={...T,...m},r=i.evaluate(t.formula,a);m[e]=r,T[e]=r}catch(t){r.error(`[RealTime-Calc Endpoint] Error calculating ${l}.${e}:`,t.message),m[e]=null}}t.json({success:!0,updates:m,message:`Calculated ${Object.keys(m).length} field(s)`})}catch(e){r.error("[RealTime-Calc Endpoint] Error calculating fields:",e),t.status(500).json({success:!1,error:e.message})}}),e.get("/",(e,t)=>{t.json({success:!0,message:"Directus Real-Time Calculator",version:"1.0.0",endpoints:{"GET /":"This help message","GET /status":"Get system status and formula count","POST /reload":"Reload formulas from database","POST /test-formula":"Test a formula with sample data","POST /calculate":"Calculate fields without DB write (preview)","POST /clear-cache":"Clear formula cache","POST /utils/realtime-calc.reload-formulas":"Reload formulas (Flow-compatible)","POST /utils/realtime-calc.get-config":"Get configuration (Flow-compatible)","POST /utils/realtime-calc.recalculate-collection":"Batch recalculate collection"},examples:{testFormula:{endpoint:"POST /realtime-calc/test-formula",body:{formula:"{{prix_ht}} * (1 + {{tva_rate}})",sampleData:{prix_ht:100,tva_rate:.2}},description:"Test a formula before saving it"},calculate:{endpoint:"POST /realtime-calc/calculate",body:{collection:"products",data:{prix_ht:100,tva_rate:.2},fields:["prix_ttc"]},description:"Preview calculated values without saving"},recalculate:{endpoint:"POST /realtime-calc/utils/realtime-calc.recalculate-collection",body:{collection:"products",filter:{status:{_eq:"published"}},batchSize:100,dryRun:!0},description:"Batch recalculate items in a collection"},clearCache:{endpoint:"POST /realtime-calc/clear-cache",body:{},description:"Clear formula cache manually"}},note:"Real-time calculation with 60+ DSL functions including math, string, date, and conditional operations"})})}}],R=[];export{C as endpoints,y as hooks,R as operations};
